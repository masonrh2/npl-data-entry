<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NPL Data Entry</title>
    <link rel="stylesheet" href="https://ssl.gstatic.com/docs/script/css/add-ons1.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>
    <?!= include('css')?>
  </head>
  <body onload="doOnload()" style="margin: 1em;">
    <div class="header" style="display: block; padding: 1em; overflow: auto;">
      <img src="https://drive.google.com/uc?id=1JLX7vfDnqgYd_OrgPNtvj1sqV8n4ANpd"/>
      <h1>NPL Data Entry</h1>
    </div>
    <div id="timestamp" style="display: none; margin-bottom: 1em;">
      <p style="display: inline;"></p><button style="margin-left: 1em" onclick="updateDatabase()">Refresh Database</button>
    </div>
    <div id="loadingDatabase" style="display: none;">Loading Database...</div>
    <div id="submittingData" style="display: none;">Submitting Data...</div>
    <div id="sectionSelection" class="hideWhenLoading" style="display: none;">
      <button onclick="loadTungsten()">Tungsten</button>
      <button onclick="loadEpoxy()">Epoxy</button>
      <button onclick="loadDensity()">Density</button>
      <section style="display: inline-block; margin-top: 1em;">
        <form action="javascript:onLogBlock()" style="display: none;">
          <label>log block: </label><input type="text" id="logBlockInput">
          <button id="logBlockButton">submit</button>
        </form>
		  </section>
    </div>
    <section id="tungstenSection" class="dataEntrySection hideWhenLoading" style="display: none;">
      <button onclick="sectionReturn()">Back</button>
      <button onclick="generalSubmitData(tungstenSettings)">SUBMIT</button><br>
      <form action="javascript:" onsubmit="batchInput(this, 'inputPowder')" style="margin-top: 1em; display: block;">
        <label style="font-weight: bold; width: 120px; display: inline-block;">Powder: </label>
          <input type="text" style="width: 80px;" value="HCS">
        <button style="margin-left: 1em">Submit</button>
      </form>
      <form action="javascript:" onsubmit="batchInput(this, 'inputBucket')" style="margin-top: 1em; display: block;">
        <label style="font-weight: bold; width: 120px; display: inline-block;">Bucket #: </label>
          <input type="text" style="width: 80px;" value="HCS-">
        <button style="margin-left: 1em">Submit</button>
      </form>
      <form action="javascript:" onsubmit="batchInput(this, 'inputDate')" style="margin-top: 1em; display: block;">
        <label style="font-weight: bold; width: 120px; display: inline-block;">Date: </label>
          <input type="text" class="batchDateUS" style="width: 80px;">
        <button style="margin-left: 1em">Submit</button>
      </form>
      <form action="javascript:" onsubmit="batchInput(this, 'inputFiller')" style="margin-top: 1em; display: block;">
        <label style="font-weight: bold; width: 120px; display: inline-block;">Filler Initials: </label>
          <input type="text" style="width: 80px;">
        <button style="margin-left: 1em">Submit</button>
      </form>
      <div id="tungstenGridTable" class="grid"></div>
      <button onclick="addRowByConfig(tungstenSettings, 1)" style="margin-top: 1em;">Add Row</button>
    </section>
    <section id="epoxySection" class="dataEntrySection hideWhenLoading" style="display: none;">
      <button onclick="sectionReturn()">Back</button>
      <button onclick="generalSubmitData(epoxySettings)">SUBMIT</button><br>
      <form action="javascript:" onsubmit="batchInput(this, 'inputBatch')" style="margin-top: 1em; display: block;">
        <label style="font-weight: bold; width: 120px; display: inline-block;">Epoxy Batch: </label>
          <input type="text" style="width: 80px;">
        <button style="margin-left: 1em">Submit</button>
      </form>
      <form action="javascript:" onsubmit="batchInput(this, 'inputResinMass')" style="margin-top: 1em; display: block;">
        <label style="font-weight: bold; width: 120px; display: inline-block;">Resin Mass: </label>
          <input type="text" style="width: 80px;" value="110">
        <button style="margin-left: 1em">Submit</button>
      </form>
      <form action="javascript:" onsubmit="batchInput(this, 'inputHardenerMass')" style="margin-top: 1em; display: block;">
        <label style="font-weight: bold; width: 120px; display: inline-block;">Hardener Mass: </label>
          <input type="text" style="width: 80px;" value="25">
        <button style="margin-left: 1em">Submit</button>
      </form>
      <form action="javascript:" onsubmit="batchInput(this, 'inputPottingNotes')" style="margin-top: 1em; display: block;">
        <label style="font-weight: bold; width: 120px; display: inline-block;">Potting Notes: </label>
          <input type="text" style="width: 80px;" value="d40g">
        <button style="margin-left: 1em">Submit</button>
      </form>
      <form action="javascript:" onsubmit="batchInput(this, 'inputDate')" style="margin-top: 1em; display: block;">
        <label style="font-weight: bold; width: 120px; display: inline-block;">Date: </label>
          <input type="text" class="batchDateUS" style="width: 80px;">
        <button style="margin-left: 1em">Submit</button>
      </form>
      <form action="javascript:" onsubmit="batchInput(this, 'inputPreparer')" style="margin-top: 1em; display: block;">
        <label style="font-weight: bold; width: 120px; display: inline-block;">Preparer Initials: </label>
          <input type="text" style="width: 80px;">
        <button style="margin-left: 1em">Submit</button>
      </form>
      <div id="epoxyGridTable" class="grid"></div>
      <button onclick="addRowByConfig(epoxySettings, 1)" style="margin-top: 1em;">Add Row</button>
    </section>
    <section id="densitySection" class="dataEntrySection hideWhenLoading" style="display: none;">
      <button onclick="sectionReturn()">Back</button>
      <button onclick="generalSubmitData(densitySettings)">SUBMIT</button><br>
      <form action="javascript:" onsubmit="batchInput(this, 'inputDate')" style="margin-top: 1em; display: block;">
        <label style="font-weight: bold; width: 120px; display: inline-block;">Date: </label>
          <input type="text" class="batchDate" style="width: 80px;">
        <button style="margin-left: 1em">Submit</button>
      </form>
      <form action="javascript:" onsubmit="batchInput(this, 'inputTester')" style="margin-top: 1em; display: block;">
        <label style="font-weight: bold; width: 120px; display: inline-block;">Tester Initials: </label>
          <input type="text" style="width: 80px;">
        <button style="margin-left: 1em">Submit</button>
      </form>
      <div id="densityGridTable" class="grid"></div>
      <button onclick="addRowByConfig(densitySettings, 1)" style="margin-top: 1em;">Add Row</button>
    </section>
  </body>
  <script>
    /* global google */
    /* eslint no-undef: "error" */
    // HELPER FUNCTIONS
    function dataPresent (data) {
      return (data != null && data !== '' && data !== '#NUM!' && data !== '#DIV/0!' && data !== 'NaN')
    }
    function to2digits (string) {
      if (string.length < 2) {
        return '0' + string
      } else {
        return string
      }
    }
    function dateToYYYYMMDD (date) {
      const y = date.getFullYear().toString()
      let m = (date.getMonth() + 1).toString()
      let d = date.getDate().toString()
      if (m.length === 1) { m = '0' + m }
      if (d.length === 1) { d = '0' + d }
      return parseInt(y + m + d)
    }
    function dateToUS (date) {
      const m = (date.getMonth() + 1).toString()
      const d = (date.getDate()).toString()
      const y = (date.getFullYear()).toString()
      return m + '/' + d + '/' + y
    }
    /**
      * calculates the volume of a block
      * @param {Number[]} dimensions The dimensions of the block (in) as [l,bt,bb,bh,st,sb,sh]
      * @return {Number} The volume of the block (mL)
      */
    function getVolume (dimensions) {
      const l = dimensions[0]
      const bt = dimensions[1]
      const bb = dimensions[2]
      const bh = dimensions[3]
      const st = dimensions[4]
      const sb = dimensions[5]
      const sh = dimensions[6]
      return 16.39 * l * (1 / 2) * (((bt + bb) * bh / 2) + ((st + sb) * sh / 2))
    }
    /**
      * @param {Number}
      * @return {String}
      */
    function columnToLetter (column) {
      let temp = ''
      let letter = ''
      while (column > 0) {
        temp = (column - 1) % 26
        letter = String.fromCharCode(temp + 65) + letter
        column = (column - temp - 1) / 26
      }
      return letter
    }
    /**
      * @param {String}
      * @return {Number} the (one-based) column index
      */
    function letterToColumn (letter) {
      let column = 0
      const length = letter.length
      for (let i = 0; i < length; i++) {
        column += (letter.charCodeAt(i) - 64) * Math.pow(26, length - i - 1)
      }
      return column
    }
    // CONSTANTS
    // store the ZERO-BASED index for each column
    const columns = {
      dbn: 0,
      block: 2,
      status: 3,
      shipment: 4,
      shipmentDate: 5,
      comment: 6,
      sector: 7,
      powder: 14,
      bucket: 15,
      moldSeries: 16,
      emptyMoldMass: 17,
      filledMoldMass: 18,
      tungstenMass: 19,
      tungstenFillingDate: 21,
      tungstenFiller: 22,
      epoxyBatch: 23,
      resinMass: 24,
      hardenerMass: 25,
      pottingNotes: 26,
      epoxyFillingTime: 27,
      epoxyFillingDate: 28,
      epoxyPreparer: 29,
      machiningDate: 31,
      l: 33,
      bt: 34,
      bb: 35,
      bh: 36,
      st: 37,
      sb: 38,
      sh: 39,
      volume: 40,
      dimensionTester: 41,
      mass: 42,
      massTester: 43,
      density: 44,
      densityDate: 45,
      goodEnd: 47,
      fiberPercentage: 49,
      tower1: 55,
      tower2: 56,
      tower3: 57,
      tower4: 58,
      missingRow: 59,
      thirteenHoles: 60,
      lightTransTester: 63,
      lightTransDate: 64,
      scintillation: 65,
      scintRatio: 67,
      scintDate: 69,
      natLightDate: 70,
      natLightTester: 71,
      densityCheckedBy: 73,
      lightTransCheckedBy: 74,
      natLightCheckedBy: 75,
      pregrade: 80
    }
    // stores the expected dimensions for each block type
    // BL      L       BT      BB      BH      ST      SB      SH
    const dimensionsMap = new Map([
      [123, [5.5000, 2.0850, 2.0850, 1.9890, 1.8150, 1.8150, 1.9890]],
      [4, [5.4460, 2.0850, 2.0820, 2.2740, 1.8180, 1.8150, 1.9900]],
      [5, [5.3500, 2.0850, 2.0760, 2.2630, 1.8230, 1.8150, 1.9900]],
      [6, [5.2700, 2.0850, 2.0710, 2.2530, 1.8280, 1.8150, 1.9900]],
      [7, [5.2050, 2.0850, 2.0650, 2.2430, 1.8320, 1.8150, 1.9900]],
      [8, [5.1550, 2.0850, 2.0600, 2.2340, 1.8370, 1.8150, 1.9890]],
      [9, [5.1180, 2.0850, 2.0560, 2.2250, 1.8410, 1.8150, 1.9890]],
      [10, [5.0940, 2.0850, 2.0510, 2.2160, 1.8460, 1.8150, 1.9890]],
      [11, [5.0820, 2.0850, 2.0470, 2.2080, 1.8500, 1.8150, 1.9890]],
      [12, [5.0810, 2.0850, 2.0420, 2.2010, 1.8530, 1.8150, 1.9890]],
      [13, [5.0900, 2.0850, 2.0390, 2.1930, 1.8570, 1.8150, 1.9890]],
      [14, [5.1100, 2.0850, 2.0350, 2.1860, 1.8600, 1.8150, 1.9890]],
      [15, [5.1390, 2.0850, 2.0320, 2.1800, 1.8640, 1.8150, 1.9890]],
      [16, [5.1770, 2.0850, 2.0280, 2.1740, 1.8670, 1.8150, 1.9890]],
      [17, [5.2240, 2.0850, 2.0250, 2.1680, 1.8700, 1.8150, 1.9890]],
      [18, [5.2790, 2.0850, 2.0230, 2.1620, 1.8720, 1.8150, 1.9890]],
      [19, [5.3420, 2.0850, 2.0200, 2.1570, 1.8750, 1.8150, 1.9890]],
      [20, [5.4120, 2.0850, 2.0180, 2.1520, 1.8770, 1.8150, 1.9890]],
      [21, [5.4890, 2.0850, 2.0150, 2.1470, 1.8790, 1.8150, 1.9890]],
      [22, [5.5720, 2.0850, 2.0130, 2.1420, 1.8810, 1.8150, 1.9890]],
      [23, [5.6620, 2.0850, 2.0120, 2.1380, 1.8830, 1.8150, 1.9890]],
      [24, [5.7580, 2.0850, 2.0100, 2.1330, 1.8850, 1.8150, 1.9890]]
    ])
    // CLASS DEFINITIONS
    class Block {
      constructor (array, sheet, row, index) {
        this.sheet = sheet
        this.row = row
        this.index = index
        this.dbn = array[0]
        this.block = parseInt(array[2])
        this.status = array[3]
        this.powder = (!dataPresent(array[14])) ? null : array[14]
        this.bucket = (!dataPresent(array[15])) ? null : array[15]
        this.moldSeries = (!dataPresent(array[16])) ? null : array[16]
        this.emptyMoldMass = (!dataPresent(array[17])) ? null : parseInt(array[17])
        this.filledMoldMass = (!dataPresent(array[18])) ? null : parseInt(array[18])
        this.tungstenMass = (!dataPresent(array[19]) || parseInt(array[19]) === 0) ? null : parseInt(array[19])
        this.tungstenFillingDate = (!dataPresent(array[21])) ? null : array[21]
        this.tungstenFiller = (!dataPresent(array[22])) ? null : array[22]
        this.epoxyBatch = (!dataPresent(array[23])) ? null : parseInt(array[23])
        this.resinMass = (!dataPresent(array[24])) ? null : parseInt(array[24])
        this.hardenerMass = (!dataPresent(array[25])) ? null : parseInt(array[25])
        this.pottingNotes = (!dataPresent(array[26])) ? null : array[26]
        this.epoxyFillingTime = (!dataPresent(array[27])) ? null : parseFloat(array[27])
        this.epoxyFillingDate = (!dataPresent(array[28])) ? null : array[28]
        this.epoxyPreparer = (!dataPresent(array[29])) ? null : array[29]
        this.l = (!dataPresent(array[33])) ? null : parseFloat(array[33])
        this.bt = (!dataPresent(array[34])) ? null : parseFloat(array[34])
        this.bb = (!dataPresent(array[35])) ? null : parseFloat(array[35])
        this.bh = (!dataPresent(array[36])) ? null : parseFloat(array[36])
        this.st = (!dataPresent(array[37])) ? null : parseFloat(array[37])
        this.sb = (!dataPresent(array[38])) ? null : parseFloat(array[38])
        this.sh = (!dataPresent(array[39])) ? null : parseFloat(array[39])
        this.volume = (!dataPresent(array[40]) || parseInt(array[40]) === 0) ? null : parseFloat(array[40])
        this.dimensionTester = (!dataPresent(array[41])) ? null : array[41]
        this.mass = (!dataPresent(array[42])) ? null : parseInt(array[42])
        this.massTester = (!dataPresent(array[43])) ? null : array[43]
        this.density = (!dataPresent(array[44])) ? null : parseFloat(array[44])
        this.densityDate = (!dataPresent(array[45])) ? null : parseInt(array[45])
      }

      deviations () {
        const tols = [this.l, this.bt, this.bb, this.bh, this.st, this.sb, this.sh]
        if (tols.every((value) => value != null)) {
          const devs = []
          tols.forEach(function (value, index) { devs[index] = value - dimensionsMap.get(this.block)[index] })
          return devs
        } else {
          return null
        }
      }

      testGrades () {
        if (this.sheet === 0) {
          const devs = this.deviations()
          const devGrades = new Array(7)
          if (devs == null) {
            devGrades.fill(notStartedGrade)
          } else {
            for (let i = 0; i < devs.length; i++) {
              if (i === 0) {
                devGrades[0] = (devs[0] == null) ? notStartedGrade : grade_dL(devs[0])
              } else {
                devGrades[i] = (devs[i] == null) ? notStartedGrade : grade_otherDev(devs[i])
              }
            }
          }
          const densityValuesToGrade = [
            ((this.density == null) ? notStartedGrade : grade_density(this.density)),
            ...devGrades
          ]
          const densityGrade = Math.max(...densityValuesToGrade)
          return {
            density: densityGrade,
            tolerances: devGrades
          }
        } else {
          return null
        }
      }
    }
    class BlocksCollection {
      constructor (array) {
        this.array = array
        // console.log('new blocks collection with array length ' + array.length)
      }

      getBlockByIndex (index) {
        return this.array[index]
      }
    
      getBlockByLocation (sheet, row) {
        let index
        // shame we can't use a binary search here (string DBNs are not sorted), but it really doesn't take that long
        this.array.forEach(function (block, _index, array) {
          if (block.sheet === sheet && block.row === row) {
            index = _index
          }
        })
        if (index != null) { return this.array[index] }
      }

      getBlockByStringDBN (stringDBN) {
        let index
        // shame we can't use a binary search here (string DBNs are not sorted), but it really doesn't take that long
        this.array.forEach(function (block, _index, array) {
          if (stringDBN === block.dbn) {
            index = _index
          }
        })
        if (index != null) { return this.array[index] }
      }
    
      updateBlock (rowData, sheet, row) {
        const dbn = rowData[0]
        const block = this.getBlockByStringDBN(dbn)
        if (block != null) {
          const i = block.index
          this.array[i] = new Block(rowData, sheet, row, i)
        }
      }

      getBlocksNeedingRetouch (retouchStatus) {
        const blocks = []
        const devNames = ['L', 'BT', 'BB', 'BH', 'ST', 'SB', 'SH']
        const allowedStatuses = ['5', '5a', '5b', '5c']
        this.array.forEach(function (block) {
          if (block.deviations() != null && block.retouch === retouchStatus && allowedStatuses.includes(block.status)) {
            const retouchDevs = []
            block.deviations().forEach(function (dev, index) {
              if (index === 0) {
                if (grade_dL(dev) === fGrade && dev > 0) {
                  retouchDevs.push([devNames[index], dev])
                }
              } else if (grade_otherDev(dev) === fGrade && dev > 0) {
                retouchDevs.push([devNames[index], '+' + dev.toFixed(4)])
              }
            })
            if (retouchDevs.length > 0) {
              blocks.push([block, retouchDevs])
            }
          }
        })
        return blocks
      }
    }
    //
    // could have two types, error (don't try to submit) and warning (ask for confirmation)
    // (although these esentially do the same thing)
    //  data validation rules for input data
    const validate = {
      powder: function (data) {
        if (data === 'HCS') {
          return {
            valid: true,
            msg: null
          }
        } else {
          return {
            valid: false,
            msg: "expected 'HCS'"
          }
        }
      }, // handled by database data validation
      bucket: function (data) {
        const split = data.split('-')
        if (split.length !== 2) {
          return {
            valid: false,
            msg: "expected '-'"
          }
        } else {
          const pre = split[0]
          const suf = split[1]
          if (pre !== 'HCS') {
            return {
              valid: false,
              msg: "expected bucket to begin with 'HCS'"
            }
          } else if (suf === '' || isNaN(suf)) {
            return {
              valid: false,
              msg: "expected number after 'HCS'"
            }
          } else {
            return {
              valid: true,
              msg: null
            }
          }
        }
      }, // handled by database data validation
      // moldSeries: function (data) {return true}, // handled by database data validation
      emptyMoldMass: validNumber,
      filledMoldMass: validNumber,
      tungstenFillingDate: validUSDate,
      tungstenFiller: validInitials, // handled by database data validation
      epoxyBatch: validNumber, // handled by database data validation
      resinMass: validNumber, // handled by database data validation
      hardenerMass: validNumber, // handled by database data validation
      pottingNotes: function (data) {
        if (data === 'd40g') {
          return {
            valid: true,
            msg: null
          }
        } else {
          return {
            valid: false,
            msg: "expected 'd40g'"
          }
        }
      },
      epoxyFillingTime: validNumber,
      epoxyFillingDate: validUSDate,
      epoxyPreparer: validInitials, // handled by database data validation
      l: validNumber,
      bt: validNumber,
      bb: validNumber,
      bh: validNumber,
      st: validNumber,
      sb: validNumber,
      sh: validNumber,
      dimensionTester: validInitials, // should always be the same as mass tester, which is handled by database data validation
      mass: validNumber,
      massTester: validInitials, // handled by database data validation
      densityDate: validYYYYMMDD
    }
    function validNumber (str) {
      if (str !== '' && !isNaN(str)) {
        return {
          valid: true,
          msg: null
        }
      } else {
        return {
          valid: false,
          msg: 'expected a number'
        }
      }
    }
    function validUSDate (str) {
      const split = str.split('/')
      if (split.length !== 3) {
        return {
          valid: false,
          msg: "expected two /'s in US date"
        }
      }
      let m = split[0]
      let d = split[1]
      let y = split[2]
      if (isNaN(y) || isNaN(m) || isNaN(d)) {
        return {
          valid: false,
          msg: "expected numbers between /'s"
        }
      }
      y = Number(y)
      m = Number(m)
      d = Number(d)
      if (y > 2000 && m < 13 && d < 32) {
        return {
          valid: true,
          msg: null
        }
      } else {
        return {
          valid: false,
          msg: 'expected a valid US Date (month/day/year)'
        }
      }
    }
    function validInitials (str) {
      if (str.length === 2) {
        return {
          valid: true,
          msg: null
        }
      } else {
        return {
          valid: false,
          msg: 'expected initials (two characters)'
        }
      }
    }
    function validYYYYMMDD (str) {
      if (str.length !== 8) {
        return {
          valid: false,
          msg: 'expected 8 characters (YYYYMMDD)'
        }
      }
      let y = str.substr(0, 4)
      let m = str.substr(4, 2)
      let d = str.substr(6, 2)
      if (isNaN(y) || isNaN(m) || isNaN(d)) {
        return {
          valid: false,
          msg: 'expected only numberic characters'
        }
      }
      y = Number(y)
      m = Number(m)
      d = Number(d)
      if (y > 2000 && m < 13 && d < 32) {
        return {
          valid: true,
          msg: null
        }
      } else {
        return {
          valid: false,
          msg: 'expected a valid date (YYYYMMDD)'
        }
      }
    }

    // TABLE CONFIGURATIONS
    const tungstenConfig = [
      {
        headerName: 'DBN',
        propertyName: 'dbn',
        width: 1,
        minWidth: 60,
        numeric: false,
        toFixed: null,
        update: false,
        input: true,
        batchInputClass: null,
        disabled: false,
        calculation: null
      },
      {
        headerName: 'Powder',
        propertyName: 'powder',
        width: 2,
        minWidth: 60,
        numeric: false,
        toFixed: null,
        update: true,
        input: true,
        batchInputClass: 'inputPowder',
        disabled: true,
        calculation: null
      },
      {
        headerName: 'Bucket #',
        propertyName: 'bucket',
        width: 2,
        minWidth: 60,
        numeric: false,
        toFixed: null,
        update: true,
        input: true,
        batchInputClass: 'inputBucket',
        disabled: true,
        calculation: null
      },
      {
        headerName: 'Mold #',
        propertyName: 'moldSeries',
        width: 1,
        minWidth: 60,
        numeric: false,
        toFixed: null,
        update: true,
        input: true,
        batchInputClass: null,
        disabled: true,
        calculation: null
      },
      {
        headerName: 'Empty Mass (g)',
        propertyName: 'emptyMoldMass',
        width: 2,
        minWidth: 100,
        numeric: true,
        toFixed: null,
        update: true,
        input: true,
        batchInputClass: null,
        disabled: true,
        calculation: null
      },
      {
        headerName: 'Filled Mass (g)',
        propertyName: 'filledMoldMass',
        width: 2,
        minWidth: 100,
        numeric: true,
        toFixed: null,
        update: true,
        input: true,
        batchInputClass: null,
        disabled: true,
        calculation: null
      },
      {
        headerName: 'Filling Date',
        propertyName: 'tungstenFillingDate',
        width: 2,
        minWidth: 80,
        numeric: false,
        toFixed: null,
        update: true,
        input: true,
        batchInputClass: 'inputDate',
        disabled: true,
        calculation: null
      },
      {
        headerName: 'Filler Initials',
        propertyName: 'tungstenFiller',
        width: 2,
        minWidth: 80,
        numeric: false,
        toFixed: null,
        update: true,
        input: true,
        batchInputClass: 'inputFiller',
        disabled: true,
        calculation: null
      }
    ]
    const epoxyConfig = [
      {
        headerName: 'DBN',
        propertyName: 'dbn',
        width: 1,
        minWidth: 60,
        numeric: false,
        toFixed: null,
        update: false,
        input: true,
        batchInputClass: null,
        disabled: false,
        calculation: null
      },
      {
        headerName: 'Batch',
        propertyName: 'epoxyBatch',
        width: 1,
        minWidth: 60,
        numeric: false,
        toFixed: null,
        update: true,
        input: true,
        batchInputClass: 'inputBatch',
        disabled: true,
        calculation: null
      },
      {
        headerName: 'Resin Mass (g)',
        propertyName: 'resinMass',
        width: 2,
        minWidth: 100,
        numeric: true,
        toFixed: null,
        update: true,
        input: true,
        batchInputClass: 'inputResinMass',
        disabled: true,
        calculation: null
      },
      {
        headerName: 'Hardener Mass (g)',
        propertyName: 'hardenerMass',
        width: 2,
        minWidth: 120,
        numeric: true,
        toFixed: null,
        update: true,
        input: true,
        batchInputClass: 'inputHardenerMass',
        disabled: true,
        calculation: null
      },
      {
        headerName: 'Potting Notes',
        propertyName: 'pottingNotes',
        width: 2,
        minWidth: 100,
        numeric: false,
        toFixed: null,
        update: true,
        input: true,
        batchInputClass: 'inputPottingNotes',
        disabled: true,
        calculation: null
      },
      {
        headerName: 'Filling Time (min)',
        propertyName: 'epoxyFillingTime',
        width: 2,
        minWidth: 80,
        numeric: true,
        toFixed: null,
        update: true,
        input: true,
        batchInputClass: null,
        disabled: true,
        calculation: null
      },
      {
        headerName: 'Filling Date',
        propertyName: 'epoxyFillingDate',
        width: 2,
        minWidth: 80,
        numeric: false,
        toFixed: null,
        update: true,
        input: true,
        batchInputClass: 'inputDate',
        disabled: true,
        calculation: null
      },
      {
        headerName: 'Preparer Initials',
        propertyName: 'epoxyPreparer',
        width: 2,
        minWidth: 100,
        numeric: false,
        toFixed: null,
        update: true,
        input: true,
        batchInputClass: 'inputPreparer',
        disabled: true,
        calculation: null
      }
    ]
    const densityConfig = [
      {
        headerName: 'DBN',
        propertyName: 'dbn',
        width: 1,
        minWidth: 60,
        numeric: false,
        toFixed: null,
        update: false,
        input: true,
        batchInputClass: null,
        disabled: false,
        calculation: null
      },
      {
        headerName: 'L (in)',
        propertyName: 'l',
        width: 1,
        minWidth: 60,
        numeric: true,
        toFixed: 4,
        update: true,
        input: true,
        batchInputClass: null,
        disabled: true,
        calculation: null
      },
      {
        headerName: 'BT (in)',
        propertyName: 'bt',
        width: 1,
        minWidth: 60,
        numeric: true,
        toFixed: 4,
        update: true,
        input: true,
        batchInputClass: null,
        disabled: true,
        calculation: null
      },
      {
        headerName: 'BB (in)',
        propertyName: 'bb',
        width: 1,
        minWidth: 60,
        numeric: true,
        toFixed: 4,
        update: true,
        input: true,
        batchInputClass: null,
        disabled: true,
        calculation: null
      },
      {
        headerName: 'BH (in)',
        propertyName: 'bh',
        width: 1,
        minWidth: 60,
        numeric: true,
        toFixed: 4,
        update: true,
        input: true,
        batchInputClass: null,
        disabled: true,
        calculation: null
      },
      {
        headerName: 'ST (in)',
        propertyName: 'st',
        width: 1,
        minWidth: 60,
        numeric: true,
        toFixed: 4,
        update: true,
        input: true,
        batchInputClass: null,
        disabled: true,
        calculation: null
      },
      {
        headerName: 'SB (in)',
        propertyName: 'sb',
        width: 1,
        minWidth: 60,
        numeric: true,
        toFixed: 4,
        update: true,
        input: true,
        batchInputClass: null,
        disabled: true,
        calculation: null
      },
      {
        headerName: 'SH (in)',
        propertyName: 'sh',
        width: 1,
        minWidth: 60,
        numeric: true,
        toFixed: 4,
        update: true,
        input: true,
        batchInputClass: null,
        disabled: true,
        calculation: null
      },
      {
        headerName: 'Volume',
        propertyName: 'volume',
        width: 1,
        minWidth: 60,
        numeric: true,
        toFixed: null,
        update: false,
        input: false,
        batchInputClass: null,
        disabled: false,
        calculation: {
          hasData: function (index, rowData, block) {
            const blockDimensions = [block.l, block.bt, block.bb, block.bh, block.st, block.sb, block.sh]
            const inputDimensions = [
              rowData[densitySettings.properties.l].value,
              rowData[densitySettings.properties.bt].value,
              rowData[densitySettings.properties.bb].value,
              rowData[densitySettings.properties.bh].value,
              rowData[densitySettings.properties.st].value,
              rowData[densitySettings.properties.sb].value,
              rowData[densitySettings.properties.sh].value
            ]
            const useDimensions = []
            for (let i = 0; i < inputDimensions.length; i++) {
              const inputValue = inputDimensions[i]
              if (inputValue !== '' && !isNaN(inputValue)) {
                useDimensions.push(Number(inputValue))
              } else {
                useDimensions.push(blockDimensions[i])
              }
            }
            if (useDimensions.every((element) => element != null)) {
              const vol = getVolume(useDimensions)
              const inputMass = rowData[densitySettings.properties.mass].value
              const mass = inputMass !== '' && !isNaN(inputMass) ? Number(inputMass) : block.mass
              let density
              if (mass != null) { density = mass / vol }
              if (density != null) {
                rowData[densitySettings.properties.density].innerHTML = density.toFixed(2)
              } else {
                rowData[densitySettings.properties.density].innerHTML = ''
              }
              // grade these and display checkmark or something like that (don't make the colors confusing..)
              // (see info station for checkmarks, etc)
              rowData[index].innerHTML = vol.toFixed(1)
            } else {
              rowData[index].innerHTML = ''
              rowData[densitySettings.properties.density].innerHTML = ''
            }
          },
          noData: function (index, rowData, block) {
            rowData[index].innerHTML = ''
            rowData[densitySettings.properties.density].innerHTML = ''
          }
        }
      },
      {
        headerName: 'Density (g/mL)',
        propertyName: 'density',
        width: 1,
        minWidth: 60,
        numeric: true,
        toFixed: null,
        update: false,
        input: false,
        batchInputClass: null,
        disabled: false,
        calculation: null
      },
      {
        headerName: 'Tester Initials',
        propertyName: 'dimensionTester',
        width: 2,
        minWidth: 100,
        numeric: false,
        toFixed: null,
        update: true,
        input: true,
        batchInputClass: 'inputTester',
        disabled: true,
        calculation: null
      },
      {
        headerName: 'Mass (g)',
        propertyName: 'mass',
        width: 1,
        minWidth: 60,
        numeric: true,
        toFixed: null,
        update: true,
        input: true,
        batchInputClass: null,
        disabled: true,
        calculation: null
      },
      {
        headerName: 'Tester Initials',
        propertyName: 'massTester',
        width: 2,
        minWidth: 100,
        numeric: false,
        toFixed: null,
        update: true,
        input: true,
        batchInputClass: 'inputTester',
        disabled: true,
        calculation: null
      },
      {
        headerName: 'Date',
        propertyName: 'densityDate',
        width: 2,
        minWidth: 80,
        numeric: false,
        toFixed: null,
        update: true,
        input: true,
        batchInputClass: 'inputDate',
        disabled: true,
        calculation: null
      }
    ]
    const tungstenRows = []
    const epoxyRows = []
    const densityRows = []
    const tungstenSettings = {
      config: tungstenConfig,
      table: $('#tungstenGridTable'),
      properties: null,
      rows: tungstenRows
    }
    const epoxySettings = {
      config: epoxyConfig,
      table: $('#epoxyGridTable'),
      properties: null,
      rows: epoxyRows
    }
    const densitySettings = {
      config: densityConfig,
      table: $('#densityGridTable'),
      properties: null,
      rows: densityRows
    }
    const allSettings = [tungstenSettings, epoxySettings, densitySettings]
    let currentDate
    let database
    const headers = []
    const sheetNames = ['Blocks DB', 'Blocks1364DB']
    let blocksCollection
    let lastDatabaseLoad
    let reloadDatabaseTimer
    let selectedSection
    let blockPropertyToCellIndex
    function doOnload () {
      function getDatabaseOnLoad () {
        currentDate = new Date()
        document.getElementById('loadingDatabase').style.display = 'block'
        google.script.run.withSuccessHandler(onSuccess).withFailureHandler(onFailure).getDatabase()
        function onSuccess (gotDatabase) {
          lastDatabaseLoad = new Date()
          updateTimestamp()
          $('#timestamp').css('display', 'block')
          console.log('loaded database in ' + (Date.now() - currentDate.getTime()) / 1000 + ' s')
          database = [gotDatabase.sheet1, gotDatabase.sheet2]
          const blocks = []
          headers[0] = database[0][0]
          for (let i = 1; i < database[0].length; i++) {
            if (database[0][i][columns.block] !== '' && !isNaN(database[0][i][columns.block])) {
              blocks.push(new Block(database[0][i], 0, i + 1, blocks.length))
            }
          }
          headers[1] = database[1][0]
          for (let i = 1; i < database[1].length; i++) {
            if (database[1][i][columns.block] !== '' && !isNaN(database[1][i][columns.block])) {
              blocks.push(new Block(database[1][i], 1, i + 1, blocks.length))
            }
          }
          blocksCollection = new BlocksCollection(blocks)
          document.getElementById('loadingDatabase').style.display = 'none'
          document.getElementById('sectionSelection').style.display = 'block'
          selectedSection = 'sectionSelection'
          addSectionProperties()
          setupGridTables()
          addRowByConfig(tungstenSettings, 8)
          addRowByConfig(epoxySettings, 8)
          addRowByConfig(densitySettings, 8)
        }
        function onFailure (err) {
          console.warn('failed to load database...retrying in 10 seconds')
          window.setTimeout(getDatabaseOnLoad, 10 * 1000)
          throw err
        }
        $('input.batchDateUS').val(dateToUS(currentDate))
        $('input.batchDate').val(dateToYYYYMMDD(currentDate))
      }
      try {
        getDatabaseOnLoad()
      } catch (err) {
        console.error('unexpected error while getting database...retrying in 10 seconds')
        window.setTimeout(getDatabaseOnLoad, 10 * 1000)
        throw (err)
      }
    }
    function setupGridTables () {
      for (const tableSettings of allSettings) {
        addHeaders(tableSettings)
      }
      function addHeaders (tableSettings) {
        let template = ''
        for (const columnConfig of tableSettings.config) {
          tableSettings.table.append($('<div>' + columnConfig.headerName + '</div>').addClass('gridTableHeader'))
          template += columnConfig.width + 'fr '
        }
        tableSettings.table.css('grid-template-columns', template).css('margin-top', '1em')
      }
    }
    function addRowByConfig (tableSettings, count) {
      const rows = tableSettings.rows
      const table = tableSettings.table
      const tableConfig = tableSettings.config
      const numRows = Math.floor(table.children('div.gridData').length / tableConfig.length)
      for (let i = 0; i < count; i++) {
        const row = []
        const rowNum = numRows + i
        for (const config of tableConfig) {
          const element = $('<div></div>').addClass('gridData')
          let child
          if (config.input) {
            child = $('<input/>').attr('type', 'text').attr('data-row', rowNum).css('min-width', config.minWidth + 'px')
              .prop('placeholder', '').keyup(function () { generalKeyup(tableSettings, rowNum) })
            if (config.batchInputClass !== null) {
              child.addClass(config.batchInputClass)
            }
          } else {
            child = $('<p></p>').attr('data-row', rowNum).addClass('centerP').css('min-width', config.minWidth + 'px')
          }
          if (config.disabled) {
            child.prop('disabled', true).addClass('fillEmpty')
          }
          element.append(child)
          row.push(element)
        }
        table.append(row)
        const rowData = table.find('[data-row="' + (numRows + i) + '"]').toArray()
        rows.push(rowData)
      }
    }
    function generalKeyup (tableSettings, rowNum) {
      const tableConfig = tableSettings.config
      const properties = tableSettings.properties
      const rowData = tableSettings.rows[rowNum]
      const dbn = rowData[properties.dbn].value
      const block = blocksCollection.getBlockByStringDBN(dbn)
      const toUpdate = []
      for (let i = 0; i < tableConfig.length; i++) {
        if (tableConfig[i].update) {
          toUpdate.push({ element: rowData[i], config: tableConfig[i] })
        }
      }
      if (dbn !== '' && block != null) {
        // found a block, enable inputs and import data
        toUpdate.forEach(function (obj) {
          obj.element.disabled = false
          obj.element.style.backgroundColor = 'transparent'
          if (obj.config.toFixed != null && block[obj.config.propertyName] != null) {
            updateTextInput(obj.element, block[obj.config.propertyName].toFixed(obj.config.toFixed))
          } else {
            updateTextInput(obj.element, block[obj.config.propertyName])
          }
        })
        for (let i = 0; i < tableConfig.length; i++) {
          if (tableConfig[i].calculation != null) {
            tableConfig[i].calculation.hasData(i, rowData, block)
          }
        }
      } else {
        // no dbn found, disable all inputs
        toUpdate.forEach(function (obj) {
          obj.element.value = ''
          obj.element.placeholder = ''
          obj.element.disabled = true
          obj.element.style.border = '1px solid grey'
          obj.element.style.backgroundColor = '#eee'
        })
        for (let i = 0; i < tableConfig.length; i++) {
          if (tableConfig[i].calculation != null) {
            tableConfig[i].calculation.noData(i, rowData, block)
          }
        }
      }
    }
    function updateTextInput (element, databaseValue) {
      if (databaseValue != null) {
        element.placeholder = databaseValue
        if (element.value === '') {
          element.style.border = '2px solid orange'
          // we knowinglly use a castful comparison to avoid tedium
        } else if (element.value == databaseValue) {
          element.style.border = '2px solid green'
        } else {
          element.style.border = '2px solid red'
        }
      } else {
        element.placeholder = ''
        if (element.value === '') {
          element.style.border = '1px solid grey'
        } else {
          element.style.border = '2px solid green'
        }
      }
    }
    // this is quite an elegant function - I like it
    function batchInput (form, className) {
      const grid = $(form).parent('section').children('div.grid').eq(0)
      const inputVal = $(form).children('input').eq(0).val()
      grid.find('div.gridData > input.' + className).filter(':enabled').val(inputVal).keyup()
    }
    function loadTungsten () {
      document.getElementById('sectionSelection').style.display = 'none'
      document.getElementById('tungstenSection').style.display = 'block'
      selectedSection = 'tungstenSection'
    }
    function loadEpoxy () {
      document.getElementById('sectionSelection').style.display = 'none'
      document.getElementById('epoxySection').style.display = 'block'
      selectedSection = 'epoxySection'
    }
    function loadDensity () {
      document.getElementById('sectionSelection').style.display = 'none'
      document.getElementById('densitySection').style.display = 'block'
      selectedSection = 'densitySection'
    }
    function sectionReturn () {
      $('.dataEntrySection').css('display', 'none')
      document.getElementById('sectionSelection').style.display = 'block'
      selectedSection = 'sectionSelection'
    }
    function onLogBlock () {
      const blockName = document.getElementById('logBlockInput').value
      const start = Date.now()
      const block = blocksCollection.getBlockByStringDBN(blockName)
      if (block != null) {
        // google.script.run.withSuccessHandler(onSuccess).withFailureHandler(onFailure).getRowData([{sheet: block.sheet, row: block.row}])
        console.log(block)
      } else {
        console.log("unable to locate that DBN (here's where I would offer you an option to refresh the database for another opportunity to find that block)")
      }
      function onSuccess (data) {
        const blockData = data[0]
        if (blockData != null) {
          console.log('found that block in ' + (Date.now() - start) / 1000 + ' s')
          console.log(blockData)
        } else {
          console.log('unable to locate that block')
        }
      }
      function onFailure (err) {
        alert('The server encountered an uncaught error while logging block:\n' + JSON.stringify(err))
        throw err
      }
    }
    function generalSubmitData (tableSettings) {
      const blocks = []
      const values = []
      const columnNames = []
      const rows = tableSettings.rows
      for (const row of rows) {
        const stringDBN = row[tableSettings.properties.dbn].value
        if (stringDBN !== '') {
          const block = blocksCollection.getBlockByStringDBN(stringDBN)
          if (block != null) {
            blocks.push(block)
            const blockValues = []
            for (let i = 0; i < tableSettings.config.length; i++) {
              const columnConfig = tableSettings.config[i]
              if (columnConfig.input && columnConfig.update) {
                let _set = row[i].value
                if (_set !== '') {
                  let _expected = block[columnConfig.propertyName]
                  if (_expected == null) { _expected = '' }
                  // cast set value to num if needed
                  if (columnConfig.numeric && _set !== '' && !isNaN(_set)) {
                    _set = Number(_set)
                  }
                  blockValues.push({ set: _set, expected: _expected, ignoreError: false })
                } else {
                  blockValues.push(null)
                }
                columnNames.push(columnConfig.propertyName)
              }
            }
            values.push(blockValues)
          } else {
            console.error('unable to find DBN ' + stringDBN + ' (I could offer to refresh database here)')
          }
        }
      }
      submitData(blocks, columnNames, values)
    }
    
    /**
     * submits data to the database
     * @param {Block[]} blocks Array of blocks
     * @param {String[]} columnNames Names of columns (which correspond to the columns in values)
     * @param {String[][]} values Values to submit to the database (row corresponds to blocks, column corresponds to columnNames)
     */
    function submitData (blocks, columnNames, values) {
      // first, organize data to send to the google script
      const data = []
      const cols = []
      for (const name of columnNames) {
        cols.push(columns[name])
      }
      for (let i = 0; i < blocks.length; i++) {
        const block = blocks[i]
        const blockData = {}
        blockData.expectedDBN = block.dbn
        blockData.sheet = block.sheet
        blockData.row = block.row
        blockData.cols = []
        blockData.values = []
        for (let j = 0; j < values[i].length; j++) {
          if (values[i][j] != null) {
            blockData.cols.push(cols[j])
            blockData.values.push(values[i][j])
          }
        }
        data.push(blockData)
      }
      // next, check if we know this data will overwrite existing data if submitted
      const overwriteWarnings = validateOverwrites(blocks, columnNames, values)
      if (overwriteWarnings.length !== 0) {
        // if there are overwrites, ask to confirm before proceeding
        showOverwriteWarnings(overwriteWarnings, blocks, columnNames, values, data)
      } else {
        // if not, proceed to perform basic data validation before sending to google script
        const basicDataValidationWarnings = validateData(blocks, columnNames, values)
        if (basicDataValidationWarnings.length !== 0) {
          showWarnings(basicDataValidationWarnings, data)
        } else {
          // submit to the google script
          $('#' + selectedSection).css('display', 'none')
          $('#submittingData').css('display', 'block')
          google.script.run.withSuccessHandler(onSubmitDataSuccess).withFailureHandler(onFailure).setBlockData(data)
        }
      }
    
      function validateOverwrites (blocks, columnNames, values) {
        const warnings = []
        // console.log(values)
        for (let i = 0; i < values.length; i++) {
          const block = blocks[i]
          for (let j = 0; j < columnNames.length; j++) {
            const value = values[i][j]
            // console.log(value)
            if (value !== null && value.expected !== '' && value.set != value.expected) {
              warnings.push({
                set: value.set,
                prev: value.expected,
                col: columnNames[j],
                dbn: block.dbn,
                value: value.set
              })
            }
          }
        }
        return warnings
      }
      function showOverwriteWarnings (overwriteWarnings, blocks, columnNames, values, data) {
        // console.log(data)
        let warningMsg = '(WARNING) This submission would overwrite some data in the database:\n'
        for (const warn of overwriteWarnings) {
          warningMsg += 'DBN ' + warn.dbn + ', column "' + warn.col +
            '": (warning) changing value "' + warn.prev + '" â†’ "' + warn.set + '"\n'
        }
        warningMsg += 'Are you sure you want to submit this data to the database?'
        const bool = confirm(warningMsg)
        if (bool) {
          // overwrite was confirmed, perform basic data validation before sending to google script
          const warnings = validateData(blocks, columnNames, values)
          if (warnings.length !== 0) {
            showWarnings(warnings, data)
          } else {
            // submit to the google script
            $('#' + selectedSection).css('display', 'none')
            $('#submittingData').css('display', 'block')
            google.script.run.withSuccessHandler(onSubmitDataSuccess).withFailureHandler(onFailure).setBlockData(data)
          }
        }
      }
    
      function validateData (blocks, columnNames, values) {
        const warnings = []
        // console.log(values)
        for (let i = 0; i < values.length; i++) {
          const block = blocks[i]
          for (let j = 0; j < columnNames.length; j++) {
            const value = values[i][j]
            // console.log(value)
            if (value != null && Object.prototype.hasOwnProperty.call(validate, columnNames[j])) {
              const validation = validate[columnNames[j]](value.set)
              if (!validation.valid) {
                warnings.push({
                  msg: validation.msg,
                  col: columnNames[j],
                  dbn: block.dbn,
                  value: value.set
                })
              }
            }
          }
        }
        return warnings
      }
      function showWarnings (warnings, data) {
        // console.log(data)
        let warningMsg = '(WARNING) Some of the data is not as expected:\n'
        for (const warn of warnings) {
          warningMsg += 'DBN ' + warn.dbn + ', column "' + warn.col +
            '": (warning) for value "' + warn.value + '", ' + warn.msg + '\n'
        }
        warningMsg += 'Are you sure you want to submit this data to the database?'
        const bool = confirm(warningMsg)
        if (bool) {
          $('#' + selectedSection).css('display', 'none')
          $('#submittingData').css('display', 'block')
          google.script.run.withSuccessHandler(onSubmitDataSuccess).withFailureHandler(onFailure).setBlockData(data)
        }
      }
    
      function showErrorAlert (msg, data) {
        if (msg.unexpectedDBNError !== undefined) {
          const errorMsg = '(ERROR) Encountered an unexpected DBN (did a DBN change? were rows added or deleted?):\n' +
            'In sheet ' + sheetNames[msg.unexpectedDBNError.loc.sheet] + ', row ' + msg.unexpectedDBNError.loc.row +
            ', expected DBN ' + msg.unexpectedDBNError.expectedDBN + ', but found DBN ' + msg.unexpectedDBNError.foundDBN + '\n' +
            'Try refreshing the database and resubmitting (or Mason needs to fix something)'
          $('#' + selectedSection).css('display', 'block')
          $('#submittingData').css('display', 'none')
          alert(errorMsg)
        } else if (msg.dataValidationErrors.length !== 0 || msg.unexpectedValueErrors.length !== 0) {
          let errorMsg = ''
          const fatalErrors = []
          for (const error of msg.dataValidationErrors) {
            if (error.fatal) {
              fatalErrors.push(error)
            }
          }
          if (fatalErrors.length !== 0) {
            // show an alert: UNABLE to submit this data because these errors (the fatal errors)
            errorMsg += '(ERROR) Unable to submit data to the database due to these data validation errors:\n'
            for (const error of fatalErrors) {
              const dbn = blocksCollection.getBlockByLocation(error.loc.sheet, error.loc.row).dbn
              if (error.type === 'VALUE_IN_LIST') {
                errorMsg += 'In sheet ' + sheetNames[error.loc.sheet] + ', DBN ' + dbn +
                  ' (row ' + error.loc.row + '), column "' + (headers[error.loc.sheet][error.loc.col]) +
                  '": tried to write value "' + error.value + '" but cell requires a value in ' + JSON.stringify(error.args[0]) + '\n'
              } else if (error.type === 'DATE_IS_VALID_DATE') {
                errorMsg += 'In sheet ' + sheetNames[error.loc.sheet] + ', DBN ' + dbn +
                  ' (row ' + error.loc.row + '), column "' + (headers[error.loc.sheet][error.loc.col]) +
                  '": tried to write value "' + error.value + '" but cell requires a valid date\n'
              } else {
                errorMsg += 'In sheet ' + sheetNames[error.loc.sheet] + ', DBN ' + dbn +
                  ' (row ' + error.loc.row + '), column "' + (headers[error.loc.sheet][error.loc.col]) +
                  '": unknown data validation type (' + error.type + ') at value "' + error.value + '": ' + JSON.stringify(error.args[0]) + '\n'
                errorMsg += JSON.stringify(error) + '\n'
              }
            }
            $('#' + selectedSection).css('display', 'block')
            $('#submittingData').css('display', 'none')
            alert(errorMsg)
          } else {
            // no fatal errors, show warnings and ask to confirm
            if (msg.dataValidationErrors.length !== 0) {
              errorMsg += '(WARNING) Encountered the following unchecked data validation warnings while trying to write to the database:\n'
              for (const error of msg.dataValidationErrors) {
                const dbn = blocksCollection.getBlockByLocation(error.loc.sheet, error.loc.row).dbn
                if (error.type === 'VALUE_IN_LIST') {
                  errorMsg += 'In sheet ' + sheetNames[error.loc.sheet] + ', DBN ' + dbn +
                    ' (row ' + error.loc.row + '), column "' + (headers[error.loc.sheet][error.loc.col]) +
                    '": tried to write value "' + error.value + '" but cell suggests a value in ' + JSON.stringify(error.args[0]) + '\n'
                } else if (error.type === 'DATE_IS_VALID_DATE') {
                  errorMsg += 'In sheet ' + sheetNames[error.loc.sheet] + ', DBN ' + dbn +
                    ' (row ' + error.loc.row + '), column "' + (headers[error.loc.sheet][error.loc.col]) +
                    '": tried to write value "' + error.value + '" but cell suggests a valid date\n'
                } else {
                  errorMsg += 'In sheet ' + sheetNames[error.loc.sheet] + ', DBN ' + dbn +
                    ' (row ' + error.loc.row + '), column "' + (headers[error.loc.sheet][error.loc.col]) +
                    '": encountered an unknown data validation type (' + error.type + ') for value "' + error.value + '": ' + JSON.stringify(error.args[0]) + '\n'
                  errorMsg += JSON.stringify(error) + '\n'
                }
              }
            }
            if (msg.unexpectedValueErrors.length !== 0) {
              errorMsg += '(WARNING) Found the following unexpected values in the database (did these cells change since this page was loaded?):\n'
              for (const error of msg.unexpectedValueErrors) {
                const dbn = blocksCollection.getBlockByLocation(error.loc.sheet, error.loc.row).dbn
                errorMsg += 'In sheet ' + sheetNames[error.loc.sheet] + ', DBN ' + dbn +
                  ' (row ' + error.loc.row + '), column "' + (headers[error.loc.sheet][error.loc.col]) +
                  '": expected value "' + error.expected + '" but found "' + error.found + '"\n'
              }
            }
            errorMsg += 'Press OK to ignore these errors and submit this data to the database'
            const bool = confirm(errorMsg)
            if (bool) {
              for (const error of msg.dataValidationErrors.concat(msg.unexpectedValueErrors)) {
                const i = error.id[0]
                const j = error.id[1]
                data[i].values[j].ignoreError = true
              }
              google.script.run.withSuccessHandler(onSubmitDataSuccess).withFailureHandler(onFailure).setBlockData(data)
            } else {
              $('#' + selectedSection).css('display', 'block')
              $('#submittingData').css('display', 'none')
            }
          }
        } else {
          $('#' + selectedSection).css('display', 'block')
          $('#submittingData').css('display', 'none')
          const successMsg = 'Successfully wrote data to the database'
          alert(successMsg)
        }
      }
      function onSubmitDataSuccess (msg) {
        // console.log(msg)
        showErrorAlert(msg, data)
        updateBlocks(msg.newBlockData)
      }
      function onFailure (err) {
        alert('The server encountered an uncaught error while submitting data:\n' + JSON.stringify(err))
        throw err
      }
    }
    
    function updateDatabase() {
      const start = Date.now()
      document.getElementById('loadingDatabase').style.display = 'block'
      $('.hideWhenLoading').css('display', 'none')
      // console.log([$('#sectionSelection').css('display'), $('#tungstenSection').css('display'), $('#epoxySection').css('display'), $('#densitySection').css('display')])
      google.script.run.withSuccessHandler(onSuccess).withFailureHandler(onFailure).getDatabase()
      function onSuccess (sheets) {
        lastDatabaseLoad = new Date()
        console.log('loaded database in ' + (Date.now() - start) / 1000 + ' s')
        updateTimestamp()
        database = [sheets.sheet1, sheets.sheet2]
        const blocks = []
        headers[0] = database[0][0]
        for (let i = 1; i < database[0].length; i++) {
          if (database[0][i][columns.block] !== '' && !isNaN(database[0][i][columns.block])) {
            blocks.push(new Block(database[0][i], 0, i + 1, blocks.length))
          }
        }
        headers[1] = database[1][0]
        for (let i = 1; i < database[1].length; i++) {
          if (database[1][i][columns.block] !== '' && !isNaN(database[1][i][columns.block])) {
            blocks.push(new Block(database[1][i], 1, i + 1, blocks.length))
          }
        }
        blocksCollection = new BlocksCollection(blocks)
        document.getElementById('loadingDatabase').style.display = 'none'
        $('#' + selectedSection).css('display', 'block')
        updateTables()
      }
      function onFailure (err) {
        alert('The server encountered an uncaught error while refreshing database:\n' + JSON.stringify(err))
        throw err
      }
    }
    function updateBlocks (blockData) {
      if (blockData != null) {
        const rowData = blockData.rowData
        const sheets = blockData.sheets
        const rows = blockData.rows
        for (let i = 0; i < rowData.length; i++) {
          blocksCollection.updateBlock(rowData[i], sheets[i], rows[i])
        }
        updateTables()
      }
    }
    function updateTables () {
      for (let i = 0; i < tungstenRows.length; i++) {
        generalKeyup(tungstenSettings, i)
      }
      for (let i = 0; i < epoxyRows.length; i++) {
        generalKeyup(epoxySettings, i)
      }
      for (let i = 0; i < densityRows.length; i++) {
        generalKeyup(densitySettings, i)
      }
    }
    function updateTimestamp () {
      // (re)set color/style to the normal
      const timestampDiv = $('#timestamp')
      const text = 'Database loaded: ' + String(lastDatabaseLoad)
      const p = timestampDiv.children('p')
      // console.log(p)
      p.html(text).css('color', 'black').css('font-weight', 'normal')
      window.clearTimeout(reloadDatabaseTimer)
      reloadDatabaseTimer = window.setTimeout(setRed, 5 * 1000 * 60)
      function setRed () {
        p.css('color', 'red').css('font-weight', 'bold')
        alert('The script is using data which is at least 5 minutes old. Consider refreshing the database.')
      }
    }
    function addSectionProperties () {
      for (const settings of allSettings) {
        const tableConfig = settings.config
        settings.properties = {}
        for (let i = 0; i < tableConfig.length; i++) {
          settings.properties[tableConfig[i].propertyName] = i
        }
      }
      console.log(allSettings)
    }
  </script>
</html>
