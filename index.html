<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NPL Data Entry</title>
    <link rel="stylesheet" href="https://ssl.gstatic.com/docs/script/css/add-ons1.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>
    <?!= include('css')?>
  </head>
  <body onload="doOnload()" style="margin: 1em;">
    <div class="header" style="display: block; padding: 1em; overflow: auto;">
      <img src="https://drive.google.com/uc?id=1JLX7vfDnqgYd_OrgPNtvj1sqV8n4ANpd"/>
      <h1>NPL Data Entry</h1>
    </div>
    <div id="timestamp" style="display: none; margin-bottom: 1em;">
      <p style="display: inline;"></p><button style="margin-left: 1em" onclick="updateDatabase()">Refresh Database</button>
    </div>
    <div id="loadingDatabase" style="display: none;">Loading Database...</div>
    <div id="submittingData" style="display: none;">Submitting Data...</div>
    <div id="sectionSelection" class="hideWhenLoading" style="display: none;">
      <button onclick="loadTungsten()">Tungsten</button>
      <button onclick="loadEpoxy()">Epoxy</button>
      <button onclick="loadDensity()">Density</button>
      <section style="display: inline-block; margin-top: 1em;">
        <form action="javascript:onLogBlock()" style="display: none;">
          <label>log block: </label><input type="text" id="logBlockInput">
          <button id="logBlockButton">submit</button>
        </form>
		  </section>
    </div>
    <section id="tungstenSection" class="dataEntrySection hideWhenLoading" style="display: none;">
      <button onclick="sectionReturn()">Back</button>
      <button onclick="generalSubmitData(tungstenSettings)">SUBMIT</button><br>
      <form action="javascript:" onsubmit="batchInput(this, 'inputPowder')" style="margin-top: 1em; display: block;">
        <label style="font-weight: bold; width: 120px; display: inline-block;">Powder: </label>
          <input type="text" style="width: 80px;" value="HCS">
        <button style="margin-left: 1em">Submit</button>
      </form>
      <form action="javascript:" onsubmit="batchInput(this, 'inputBucket')" style="margin-top: 1em; display: block;">
        <label style="font-weight: bold; width: 120px; display: inline-block;">Bucket #: </label>
          <input type="text" style="width: 80px;" value="HCS-">
        <button style="margin-left: 1em">Submit</button>
      </form>
      <form action="javascript:" onsubmit="batchInput(this, 'inputDate')" style="margin-top: 1em; display: block;">
        <label style="font-weight: bold; width: 120px; display: inline-block;">Date: </label>
          <input type="text" class="batchDateUS" style="width: 80px;">
        <button style="margin-left: 1em">Submit</button>
      </form>
      <form action="javascript:" onsubmit="batchInput(this, 'inputFiller')" style="margin-top: 1em; display: block;">
        <label style="font-weight: bold; width: 120px; display: inline-block;">Filler Initials: </label>
          <input type="text" style="width: 80px;">
        <button style="margin-left: 1em">Submit</button>
      </form>
      <div id="tungstenGridTable" class="grid"></div>
      <button onclick="addRowByConfig(tungstenSettings, 1)" style="margin-top: 1em;">Add Row</button>
    </section>
    <section id="epoxySection" class="dataEntrySection hideWhenLoading" style="display: none;">
      <button onclick="sectionReturn()">Back</button>
      <button onclick="generalSubmitData(epoxySettings)">SUBMIT</button><br>
      <form action="javascript:" onsubmit="batchInput(this, 'inputBatch')" style="margin-top: 1em; display: block;">
        <label style="font-weight: bold; width: 120px; display: inline-block;">Epoxy Batch: </label>
          <input type="text" style="width: 80px;">
        <button style="margin-left: 1em">Submit</button>
      </form>
      <form action="javascript:" onsubmit="batchInput(this, 'inputResinMass')" style="margin-top: 1em; display: block;">
        <label style="font-weight: bold; width: 120px; display: inline-block;">Resin Mass: </label>
          <input type="text" style="width: 80px;" value="110">
        <button style="margin-left: 1em">Submit</button>
      </form>
      <form action="javascript:" onsubmit="batchInput(this, 'inputHardenerMass')" style="margin-top: 1em; display: block;">
        <label style="font-weight: bold; width: 120px; display: inline-block;">Hardener Mass: </label>
          <input type="text" style="width: 80px;" value="25">
        <button style="margin-left: 1em">Submit</button>
      </form>
      <form action="javascript:" onsubmit="batchInput(this, 'inputPottingNotes')" style="margin-top: 1em; display: block;">
        <label style="font-weight: bold; width: 120px; display: inline-block;">Potting Notes: </label>
          <input type="text" style="width: 80px;" value="d40g">
        <button style="margin-left: 1em">Submit</button>
      </form>
      <form action="javascript:" onsubmit="batchInput(this, 'inputDate')" style="margin-top: 1em; display: block;">
        <label style="font-weight: bold; width: 120px; display: inline-block;">Date: </label>
          <input type="text" class="batchDateUS" style="width: 80px;">
        <button style="margin-left: 1em">Submit</button>
      </form>
      <form action="javascript:" onsubmit="batchInput(this, 'inputPreparer')" style="margin-top: 1em; display: block;">
        <label style="font-weight: bold; width: 120px; display: inline-block;">Preparer Initials: </label>
          <input type="text" style="width: 80px;">
        <button style="margin-left: 1em">Submit</button>
      </form>
      <div id="epoxyGridTable" class="grid"></div>
      <button onclick="addRowByConfig(epoxySettings, 1)" style="margin-top: 1em;">Add Row</button>
    </section>
    <section id="densitySection" class="dataEntrySection hideWhenLoading" style="display: none;">
      <button onclick="sectionReturn()">Back</button>
      <button onclick="generalSubmitData(densitySettings)">SUBMIT</button><br>
      <form action="javascript:" onsubmit="batchInput(this, 'inputDate')" style="margin-top: 1em; display: block;">
        <label style="font-weight: bold; width: 120px; display: inline-block;">Date: </label>
          <input type="text" class="batchDate" style="width: 80px;">
        <button style="margin-left: 1em">Submit</button>
      </form>
      <form action="javascript:" onsubmit="batchInput(this, 'inputTester')" style="margin-top: 1em; display: block;">
        <label style="font-weight: bold; width: 120px; display: inline-block;">Tester Initials: </label>
          <input type="text" style="width: 80px;">
        <button style="margin-left: 1em">Submit</button>
      </form>
      <div id="densityGridTable" class="grid"></div>
      <button onclick="addRowByConfig(densitySettings, 1)" style="margin-top: 1em;">Add Row</button>
    </section>
  </body>
  <script>
    /* global google */
    /* eslint no-undef: "error" */
    // HELPER FUNCTIONS
    function dataPresent (data) {
      return (data != null && data !== '' && data !== '#NUM!' && data !== '#DIV/0!' && data !== 'NaN')
    }
    function to2digits (string) {
      if (string.length < 2) {
        return '0' + string
      } else {
        return string
      }
    }
    function dateToYYYYMMDD (date) {
      const y = date.getFullYear().toString()
      let m = (date.getMonth() + 1).toString()
      let d = date.getDate().toString()
      if (m.length === 1) { m = '0' + m }
      if (d.length === 1) { d = '0' + d }
      return parseInt(y + m + d)
    }
    function dateToUS (date) {
      const m = (date.getMonth() + 1).toString()
      const d = (date.getDate()).toString()
      const y = (date.getFullYear()).toString()
      return m + '/' + d + '/' + y
    }
    /**
      * calculates the volume of a block
      * @param {Number[]} dimensions The dimensions of the block (in) as [l,bt,bb,bh,st,sb,sh]
      * @return {Number} The volume of the block (mL)
      */
    function getVolume (dimensions) {
      const l = dimensions[0]
      const bt = dimensions[1]
      const bb = dimensions[2]
      const bh = dimensions[3]
      const st = dimensions[4]
      const sb = dimensions[5]
      const sh = dimensions[6]
      return 16.39 * l * (1 / 2) * (((bt + bb) * bh / 2) + ((st + sb) * sh / 2))
    }
    /**
      * @param {Number}
      * @return {String}
      */
    function columnToLetter (column) {
      let temp = ''
      let letter = ''
      while (column > 0) {
        temp = (column - 1) % 26
        letter = String.fromCharCode(temp + 65) + letter
        column = (column - temp - 1) / 26
      }
      return letter
    }
    /**
      * @param {String}
      * @return {Number} the (one-based) column index
      */
    function letterToColumn (letter) {
      let column = 0
      const length = letter.length
      for (let i = 0; i < length; i++) {
        column += (letter.charCodeAt(i) - 64) * Math.pow(26, length - i - 1)
      }
      return column
    }
    // CONSTANTS
    // store the ZERO-BASED index for each column
    const columns = {
      dbn: 0,
      block: 2,
      status: 3,
      shipment: 4,
      shipmentDate: 5,
      comment: 6,
      sector: 7,
      powder: 14,
      bucket: 15,
      moldSeries: 16,
      emptyMoldMass: 17,
      filledMoldMass: 18,
      tungstenMass: 19,
      tungstenFillingDate: 21,
      tungstenFiller: 22,
      epoxyBatch: 23,
      resinMass: 24,
      hardenerMass: 25,
      pottingNotes: 26,
      epoxyFillingTime: 27,
      epoxyFillingDate: 28,
      epoxyPreparer: 29,
      machiningDate: 31,
      l: 33,
      bt: 34,
      bb: 35,
      bh: 36,
      st: 37,
      sb: 38,
      sh: 39,
      volume: 40,
      dimensionTester: 41,
      mass: 42,
      massTester: 43,
      density: 44,
      densityDate: 45,
      goodEnd: 47,
      fiberPercentage: 49,
      tower1: 55,
      tower2: 56,
      tower3: 57,
      tower4: 58,
      missingRow: 59,
      thirteenHoles: 60,
      lightTransTester: 63,
      lightTransDate: 64,
      scintillation: 65,
      scintRatio: 67,
      scintDate: 69,
      natLightDate: 70,
      natLightTester: 71,
      densityCheckedBy: 73,
      lightTransCheckedBy: 74,
      natLightCheckedBy: 75,
      pregrade: 80
    }
    // stores the expected dimensions for each block type
    // BL      L       BT      BB      BH      ST      SB      SH
    const dimensionsMap = new Map([
      [123, [5.5000, 2.0850, 2.0850, 1.9890, 1.8150, 1.8150, 1.9890]],
      [4, [5.4460, 2.0850, 2.0820, 2.2740, 1.8180, 1.8150, 1.9900]],
      [5, [5.3500, 2.0850, 2.0760, 2.2630, 1.8230, 1.8150, 1.9900]],
      [6, [5.2700, 2.0850, 2.0710, 2.2530, 1.8280, 1.8150, 1.9900]],
      [7, [5.2050, 2.0850, 2.0650, 2.2430, 1.8320, 1.8150, 1.9900]],
      [8, [5.1550, 2.0850, 2.0600, 2.2340, 1.8370, 1.8150, 1.9890]],
      [9, [5.1180, 2.0850, 2.0560, 2.2250, 1.8410, 1.8150, 1.9890]],
      [10, [5.0940, 2.0850, 2.0510, 2.2160, 1.8460, 1.8150, 1.9890]],
      [11, [5.0820, 2.0850, 2.0470, 2.2080, 1.8500, 1.8150, 1.9890]],
      [12, [5.0810, 2.0850, 2.0420, 2.2010, 1.8530, 1.8150, 1.9890]],
      [13, [5.0900, 2.0850, 2.0390, 2.1930, 1.8570, 1.8150, 1.9890]],
      [14, [5.1100, 2.0850, 2.0350, 2.1860, 1.8600, 1.8150, 1.9890]],
      [15, [5.1390, 2.0850, 2.0320, 2.1800, 1.8640, 1.8150, 1.9890]],
      [16, [5.1770, 2.0850, 2.0280, 2.1740, 1.8670, 1.8150, 1.9890]],
      [17, [5.2240, 2.0850, 2.0250, 2.1680, 1.8700, 1.8150, 1.9890]],
      [18, [5.2790, 2.0850, 2.0230, 2.1620, 1.8720, 1.8150, 1.9890]],
      [19, [5.3420, 2.0850, 2.0200, 2.1570, 1.8750, 1.8150, 1.9890]],
      [20, [5.4120, 2.0850, 2.0180, 2.1520, 1.8770, 1.8150, 1.9890]],
      [21, [5.4890, 2.0850, 2.0150, 2.1470, 1.8790, 1.8150, 1.9890]],
      [22, [5.5720, 2.0850, 2.0130, 2.1420, 1.8810, 1.8150, 1.9890]],
      [23, [5.6620, 2.0850, 2.0120, 2.1380, 1.8830, 1.8150, 1.9890]],
      [24, [5.7580, 2.0850, 2.0100, 2.1330, 1.8850, 1.8150, 1.9890]]
    ])
    // CLASS DEFINITIONS
    class Block {
      constructor (array, sheet, row, index) {
        this.sheet = sheet
        this.row = row
        this.index = index
        this.dbn = array[0]
        this.block = parseInt(array[2])
        this.status = array[3]
        this.powder = (!dataPresent(array[14])) ? null : array[14]
        this.bucket = (!dataPresent(array[15])) ? null : array[15]
        this.moldSeries = (!dataPresent(array[16])) ? null : array[16]
        this.emptyMoldMass = (!dataPresent(array[17])) ? null : parseInt(array[17])
        this.filledMoldMass = (!dataPresent(array[18])) ? null : parseInt(array[18])
        this.tungstenMass = (!dataPresent(array[19]) || parseInt(array[19]) === 0) ? null : parseInt(array[19])
        this.tungstenFillingDate = (!dataPresent(array[21])) ? null : array[21]
        this.tungstenFiller = (!dataPresent(array[22])) ? null : array[22]
        this.epoxyBatch = (!dataPresent(array[23])) ? null : parseInt(array[23])
        this.resinMass = (!dataPresent(array[24])) ? null : parseInt(array[24])
        this.hardenerMass = (!dataPresent(array[25])) ? null : parseInt(array[25])
        this.pottingNotes = (!dataPresent(array[26])) ? null : array[26]
        this.epoxyFillingTime = (!dataPresent(array[27])) ? null : parseFloat(array[27])
        this.epoxyFillingDate = (!dataPresent(array[28])) ? null : array[28]
        this.epoxyPreparer = (!dataPresent(array[29])) ? null : array[29]
        this.l = (!dataPresent(array[33])) ? null : parseFloat(array[33])
        this.bt = (!dataPresent(array[34])) ? null : parseFloat(array[34])
        this.bb = (!dataPresent(array[35])) ? null : parseFloat(array[35])
        this.bh = (!dataPresent(array[36])) ? null : parseFloat(array[36])
        this.st = (!dataPresent(array[37])) ? null : parseFloat(array[37])
        this.sb = (!dataPresent(array[38])) ? null : parseFloat(array[38])
        this.sh = (!dataPresent(array[39])) ? null : parseFloat(array[39])
        this.volume = (!dataPresent(array[40]) || parseInt(array[40]) === 0) ? null : parseFloat(array[40])
        this.dimensionTester = (!dataPresent(array[41])) ? null : array[41]
        this.mass = (!dataPresent(array[42])) ? null : parseInt(array[42])
        this.massTester = (!dataPresent(array[43])) ? null : array[43]
        this.density = (!dataPresent(array[44])) ? null : parseFloat(array[44])
        this.densityDate = (!dataPresent(array[45])) ? null : parseInt(array[45])
      }

      deviations () {
        const tols = [this.l, this.bt, this.bb, this.bh, this.st, this.sb, this.sh]
        if (tols.every((value) => value != null)) {
          const devs = []
          tols.forEach(function (value, index) { devs[index] = value - dimensionsMap.get(this.block)[index] })
          return devs
        } else {
          return null
        }
      }

      testGrades () {
        if (this.sheet === 0) {
          const devs = this.deviations()
          const devGrades = new Array(7)
          if (devs == null) {
            devGrades.fill(notStartedGrade)
          } else {
            for (let i = 0; i < devs.length; i++) {
              if (i === 0) {
                devGrades[0] = (devs[0] == null) ? notStartedGrade : grade_dL(devs[0])
              } else {
                devGrades[i] = (devs[i] == null) ? notStartedGrade : grade_otherDev(devs[i])
              }
            }
          }
          const densityValuesToGrade = [
            ((this.density == null) ? notStartedGrade : grade_density(this.density)),
            ...devGrades
          ]
          const densityGrade = Math.max(...densityValuesToGrade)
          return {
            density: densityGrade,
            tolerances: devGrades
          }
        } else {
          return null
        }
      }
    }
    class BlocksCollection {
      constructor (array) {
        this.array = array
        // console.log('new blocks collection with array length ' + array.length)
      }

      getBlockByIndex (index) {
        return this.array[index]
      }
    
      getBlockByLocation (sheet, row) {
        let index
        // shame we can't use a binary search here (string DBNs are not sorted), but it really doesn't take that long
        this.array.forEach(function (block, _index, array) {
          if (block.sheet === sheet && block.row === row) {
            index = _index
          }
        })
        if (index != null) { return this.array[index] }
      }

      getBlockByStringDBN (stringDBN) {
        let index
        // shame we can't use a binary search here (string DBNs are not sorted), but it really doesn't take that long
        this.array.forEach(function (block, _index, array) {
          if (stringDBN === block.dbn) {
            index = _index
          }
        })
        if (index != null) { return this.array[index] }
      }
    
      updateBlock (rowData, sheet, row) {
        const dbn = rowData[0]
        const block = this.getBlockByStringDBN(dbn)
        if (block != null) {
          const i = block.index
          this.array[i] = new Block(rowData, sheet, row, i)
        }
      }

      getBlocksNeedingRetouch (retouchStatus) {
        const blocks = []
        const devNames = ['L', 'BT', 'BB', 'BH', 'ST', 'SB', 'SH']
        const allowedStatuses = ['5', '5a', '5b', '5c']
        this.array.forEach(function (block) {
          if (block.deviations() != null && block.retouch === retouchStatus && allowedStatuses.includes(block.status)) {
            const retouchDevs = []
            block.deviations().forEach(function (dev, index) {
              if (index === 0) {
                if (grade_dL(dev) === fGrade && dev > 0) {
                  retouchDevs.push([devNames[index], dev])
                }
              } else if (grade_otherDev(dev) === fGrade && dev > 0) {
                retouchDevs.push([devNames[index], '+' + dev.toFixed(4)])
              }
            })
            if (retouchDevs.length > 0) {
              blocks.push([block, retouchDevs])
            }
          }
        })
        return blocks
      }
    }
    const dimNames = ['l', 'bt', 'bb', 'bh', 'st', 'sb', 'sh']
    function getDevGrade (dim, dimName, blockType) {
      const index = dimNames.indexOf(dimName)
      const expected = dimensionsMap.get(blockType)[index]
      const dev = dim - expected
      const gradingFunction = dimName === 'l' ? grade_dL : grade_otherDev
      return gradingFunction(dev)
    }
    // COLORS (HEX)
    const red = '#800000'
    const blue = '#0080ff'
    const greenish = '#00ffbf'
    const purple = '#aa00ff'
    const magenta = '#ff00ff'
    const orange = '#e66000'
    const green = '#008000'
    const black = '#000000'
    const grey = '#ababab'
    // GRADING
    // larger grade values are worse
    const notStartedGrade = 0
    const aGrade = 1
    const bGrade = 2
    const cGrade = 3
    const fGrade = 4
    const testColors = [grey, green, orange, blue, red]
    const testSymbols = ['-', '✓', '!', '!', '✗']
    const checkColors = { false: grey, true: green }
    function grade_pregrade (grade) {
      if (grade === '5a') {
        return aGrade
      } else if (grade === '5b') {
        return bGrade
      } else if (grade === '5c') {
        return cGrade
      } else if (grade === '8') {
        return fGrade
      } else {
        return null
      }
    }
    function grade_density (density) {
      if (density > 8.8) {
        return aGrade
      } else if (density >= 8.7) {
        return bGrade
      } else if (density >= 8.4) {
        return cGrade
      } else {
        return fGrade
      }
    }
    function grade_dL (dL) {
      if (Math.abs(dL) <= 0.03) {
        return aGrade
      } else if (dL <= 0.05 && dL >= -0.1) {
        return bGrade
      } else {
        return fGrade
      }
    }
    function grade_otherDev (dev) {
      if (Math.abs(dev) <= 0.02) {
        return aGrade
      } else if (dev <= 0.02 && dev >= -0.04) {
        return bGrade
      } else {
        return fGrade
      }
    }
    function grade_missingRow (x) {
      if (x) {
        return fGrade
      } else {
        return aGrade
      }
    }
    function grade_thirteenHoles (x) {
      if (x) {
        return fGrade
      } else {
        return aGrade
      }
    }
    function grade_fiberPercentage (percent) {
      if (percent >= 98) {
        return aGrade
      } else if (percent >= 97) {
        return bGrade
      } else if (percent >= 96) {
        return cGrade
      } else {
        return fGrade
      }
    }
    function grade_tower (percent) {
      if (percent >= 96) {
        return aGrade
      } else if (percent >= 94) {
        return bGrade
      } else if (percent >= 92) {
        return cGrade
      } else {
        return fGrade
      }
    }
    function grade_scintRatio (ratio) {
      if (ratio >= 0.7) {
        return aGrade
      } else {
        return fGrade
      }
    }
    // BASIC (CLIENT-SIDE) DATA VALIDATION
    const validate = {
      powder: function (data) {
        if (data === 'HCS') {
          return {
            valid: true,
            msg: null
          }
        } else {
          return {
            valid: false,
            msg: "expected 'HCS'"
          }
        }
      }, // handled by database data validation
      bucket: function (data) {
        const split = data.split('-')
        if (split.length !== 2) {
          return {
            valid: false,
            msg: "expected '-'"
          }
        } else {
          const pre = split[0]
          const suf = split[1]
          if (pre !== 'HCS') {
            return {
              valid: false,
              msg: "expected bucket to begin with 'HCS'"
            }
          } else if (suf === '' || isNaN(suf)) {
            return {
              valid: false,
              msg: "expected number after 'HCS'"
            }
          } else {
            return {
              valid: true,
              msg: null
            }
          }
        }
      }, // handled by database data validation
      // moldSeries: function (data) {return true}, // handled by database data validation
      emptyMoldMass: validNumber,
      filledMoldMass: validNumber,
      tungstenFillingDate: validUSDate,
      tungstenFiller: validInitials, // handled by database data validation
      epoxyBatch: validNumber, // handled by database data validation
      resinMass: validNumber, // handled by database data validation
      hardenerMass: validNumber, // handled by database data validation
      pottingNotes: function (data) {
        if (data === 'd40g') {
          return {
            valid: true,
            msg: null
          }
        } else {
          return {
            valid: false,
            msg: "expected 'd40g'"
          }
        }
      },
      epoxyFillingTime: validNumber,
      epoxyFillingDate: validUSDate,
      epoxyPreparer: validInitials, // handled by database data validation
      l: validNumber,
      bt: validNumber,
      bb: validNumber,
      bh: validNumber,
      st: validNumber,
      sb: validNumber,
      sh: validNumber,
      dimensionTester: validInitials, // should always be the same as mass tester, which is handled by database data validation
      mass: validNumber,
      massTester: validInitials, // handled by database data validation
      densityDate: validYYYYMMDD
    }
    function validNumber (str) {
      if (str !== '' && !isNaN(str)) {
        return {
          valid: true,
          msg: null
        }
      } else {
        return {
          valid: false,
          msg: 'expected a number'
        }
      }
    }
    function validUSDate (str) {
      const split = str.split('/')
      if (split.length !== 3) {
        return {
          valid: false,
          msg: "expected two /'s in US date"
        }
      }
      let m = split[0]
      let d = split[1]
      let y = split[2]
      if (isNaN(y) || isNaN(m) || isNaN(d)) {
        return {
          valid: false,
          msg: "expected numbers between /'s"
        }
      }
      y = Number(y)
      m = Number(m)
      d = Number(d)
      if (y > 2000 && m < 13 && d < 32) {
        return {
          valid: true,
          msg: null
        }
      } else {
        return {
          valid: false,
          msg: 'expected a valid US Date (month/day/year)'
        }
      }
    }
    function validInitials (str) {
      if (str.length === 2) {
        return {
          valid: true,
          msg: null
        }
      } else {
        return {
          valid: false,
          msg: 'expected initials (two characters)'
        }
      }
    }
    function validYYYYMMDD (str) {
      if (str.length !== 8) {
        return {
          valid: false,
          msg: 'expected 8 characters (YYYYMMDD)'
        }
      }
      let y = str.substr(0, 4)
      let m = str.substr(4, 2)
      let d = str.substr(6, 2)
      if (isNaN(y) || isNaN(m) || isNaN(d)) {
        return {
          valid: false,
          msg: 'expected only numberic characters'
        }
      }
      y = Number(y)
      m = Number(m)
      d = Number(d)
      if (y > 2000 && m < 13 && d < 32) {
        return {
          valid: true,
          msg: null
        }
      } else {
        return {
          valid: false,
          msg: 'expected a valid date (YYYYMMDD)'
        }
      }
    }

    function getGradeSpan (grade) {
      const span = document.createElement('span')
      span.textContent = testSymbols[grade]
      span.style.color = testColors[grade]
      span.style.fontWeight = 'bold'
      span.classList.add('gradeSpan')
      return span.outerHTML
    }
    const defaultGradeSpan = getGradeSpan(0)
    function getDevHasData (dimName) {
      return function (index, rowData, block) {
        const input = rowData[index]
        const curSpan = $(input).parent().children('span.gradeSpan')
        const inputValue = input.value
        const placeholder = input.placeholder
        let num
        if (inputValue !== '' && !isNaN(inputValue)) {
          // then use input
          num = Number(inputValue)
        } else if (placeholder !== '' && !isNaN(placeholder)) {
          // then use block value
          num = Number(placeholder)
        }
        if (num != null) {
          const newSpan = getGradeSpan(getDevGrade(num, dimName, block.block))
          curSpan.replaceWith(newSpan)
        } else {
          curSpan.replaceWith(defaultGradeSpan)
        }
      }
    }
    function devNoData (index, rowData, block) {
      const input = rowData[index]
      const curSpan = $(input).parent().children('span.gradeSpan')
      curSpan.replaceWith(defaultGradeSpan)
    }
    function dbnChange (divRow, that) {
      const dbn = $(that).val()
      const block = dbn === '' ? null : blocksCollection.getBlockByStringDBN(dbn)
      const findBlock = $(divRow).find("span[data-name='block']")
      const blockElement = findBlock.length > 0 ? findBlock.eq(0) : null
      const findStatus = $(divRow).find("span[data-name='status']")
      const statusElement = findStatus.length > 0 ? findStatus.eq(0) : null
      if (block != null) {
        $(divRow).find('input.updateDBvlaue').each(function (index) {
          const element = this
          element.disabled = false
          element.style.backgroundColor = 'transparent'
          $(element).keyup()
        })
        if (blockElement != null) { blockElement.text(block.block) }
        if (statusElement != null) { statusElement.text(block.status) }
      } else {
        $(divRow).find('input.updateDBvlaue').each(function (index) {
          const element = this
          element.value = ''
          element.placeholder = ''
          element.disabled = true
          element.style.border = '1px solid grey'
          element.style.backgroundColor = '#eee'
        })
        if (blockElement != null) { blockElement.text('') }
        if (statusElement != null) { statusElement.text('') }
      }
    }
    function updateThisDBValue (divRow, element, toFixed) {
      const dbn = $(divRow).find("input[data-name='dbn']").val()
      const block = dbn === '' ? null : blocksCollection.getBlockByStringDBN(dbn)
      let placeholder = block[element.getAttribute('data-name')]
      if (placeholder !== null && toFixed > 0) { placeholder = placeholder.toFixed(toFixed) }
      updateTextInput(element, placeholder)
    }
    function updateTextInput (inputElement, placeholder) {
      if (placeholder != null) {
        inputElement.placeholder = placeholder
        if (inputElement.value === '') {
          inputElement.style.border = '2px solid orange'
          // we knowinglly use a castful comparison to avoid tedium
        } else if (inputElement.value == placeholder) {
          inputElement.style.border = '2px solid green'
        } else {
          inputElement.style.border = '2px solid red'
        }
      } else {
        inputElement.placeholder = ''
        if (inputElement.value === '') {
          inputElement.style.border = '1px solid grey'
        } else {
          inputElement.style.border = '2px solid green'
        }
      }
    }
    function updateStatusDiv (divRow, element, statusConfig) {

    }
    const epoxyStatusConfig = {
      errorFromStatus: [0, 7],
      goodFromStatus: [1],
      errorToStatus: [],
      goodToStatus: [2]
    }
    const tungstenStatusConfig = {
      errorFromStatus: [0, 7],
      goodFromStatus: [2],
      errorToStatus: [],
      goodToStatus: [3]
    }
    const densityStatusConfig = {
      errorFromStatus: [0, 7],
      goodFromStatus: [3, 4],
      errorToStatus: [],
      goodToStatus: [5]
    }
    // TABLE CONFIGURATIONS
    const tungstenConfig = [
      {
        headerName: 'DBN',
        colWidth: '60px',
        DOMs: [
          {
            options: {
              type: 'input',
              classes: [],
              attributes: [['data-name', 'dbn'], ['type', 'text']],
              style: [['min-width', 60]]
            },
            update: {
              numeric: false,
              fn: function (divRow, that) {
                dbnChange(divRow, that)
              }
            }
          }
        ]
      },
      {
        headerName: 'Block',
        colWidth: '60px',
        DOMs: [
          {
            options: {
              type: 'span',
              classes: [],
              attributes: [['data-name', 'block']],
              style: [['min-width', 60]]
            },
            update: {
              numeric: true,
              fn: null
            }
          }
        ]
      },
      {
        headerName: 'Status',
        colWidth: '60px',
        colWeaderWidth: '60px'65px',
        DOMs: [
          { // CURRENT STATUS
            options: {
              type: 'span',
              classes: [],
              attributes: [['data-name', 'status']],
              style: [['width', '40%'],['margin-left', '5px']]
            },
            update: {
              numeric: false,
              fn: null
            }
          },
          { // (ARROW)
            options: {
              type: 'span',
              classes: [],
              attributes: [],
              style: [['margin-left', '5px'], ['width', '20%']],
              innerHTML: '→'
            },
            update: {
              numeric: false,
              fn: null
            }
          },
          { // INPUT STATUS
            options: {
              type: 'input',
              classes: ['inputStatus'],
              attributes: [['data-name', 'status'], ['type', 'text']],
              style: [['margin-left', '5px'], ['min-width', 20], ['width', '40%']]
            },
            update: {
              numeric: false,
              fn: function (divRow, that) {
                // do some checks
              }
            }
          }
        ]
      },
      {
        headerName: 'Powder',
        colWidth: '60px',
        DOMs: [
          {
            options: {
              type: 'input',
              classes: ['inputPowder', 'updateDBvlaue'],
              attributes: [['data-name', 'powder'], ['type', 'text']],
              style: [['min-width', 60]]
            },
            update: {
              numeric: false,
              fn: function (divRow, that) {
                updateThisDBValue(divRow, that, -1)
              }
            }
          }
        ]
      },
      {
        headerName: 'Bucket #',
        colWidth: '60px',
        DOMs: [
          {
            options: {
              type: 'input',
              classes: ['inputBucket', 'updateDBvlaue'],
              attributes: [['data-name', 'bucket'], ['type', 'text']],
              style: [['min-width', 60]]
            },
            update: {
              numeric: false,
              fn: function (divRow, that) {
                updateThisDBValue(divRow, that, -1)
              }
            }
          }
        ]
      },
      {
        headerName: 'Mold #',
        colWidth: '60px',
        DOMs: [
          {
            options: {
              type: 'input',
              classes: ['updateDBvlaue'],
              attributes: [['data-name', 'moldSeries'], ['type', 'text']],
              style: [['min-width', 60]]
            },
            update: {
              numeric: false,
              fn: function (divRow, that) {
                updateThisDBValue(divRow, that, -1)
              }
            }
          }
        ]
      },
      {
        headerName: 'Empty Mass (g)',
        colWidth: '60px',
        DOMs: [
          {
            options: {
              type: 'input',
              classes: ['updateDBvlaue'],
              attributes: [['data-name', 'emptyMoldMass'], ['type', 'text']],
              style: [['min-width', 100]]
            },
            update: {
              numeric: true,
              fn: function (divRow, that) {
                updateThisDBValue(divRow, that, -1)
              }
            }
          }
        ]
      },
      {
        headerName: 'Filled Mass (g)',
        colWidth: '60px',
        DOMs: [
          {
            options: {
              type: 'input',
              classes: ['updateDBvlaue'],
              attributes: [['data-name', 'filledMoldMass'], ['type', 'text']],
              style: [['min-width', 100]]
            },
            update: {
              numeric: true,
              fn: function (divRow, that) {
                updateThisDBValue(divRow, that, -1)
              }
            }
          }
        ]
      },
      {
        headerName: 'Filling Date',
        colWidth: '60px',
        DOMs: [
          {
            options: {
              type: 'input',
              classes: ['inputDate', 'updateDBvlaue'],
              attributes: [['data-name', 'tungstenFillingDate'], ['type', 'text']],
              style: [['min-width', 80]]
            },
            update: {
              numeric: false,
              fn: function (divRow, that) {
                updateThisDBValue(divRow, that, -1)
              }
            }
          }
        ]
      },
      {
        headerName: 'Filler Initials',
        colWidth: '60px',
        DOMs: [
          {
            options: {
              type: 'input',
              classes: ['inputFiller', 'updateDBvlaue'],
              attributes: [['data-name', 'tungstenFiller'], ['type', 'text']],
              style: [['min-width', 80]]
            },
            update: {
              numeric: false,
              fn: function (divRow, that) {
                updateThisDBValue(divRow, that, -1)
              }
            }
          }
        ]
      }
    ]
    const epoxyConfig = [
      {
        headerName: 'DBN',
        colWidth: '60px',
        DOMs: [
          {
            options: {
              type: 'input',
              classes: [],
              attributes: [['data-name', 'dbn'], ['type', 'text']],
              style: [['min-width', 60]]
            },
            update: {
              numeric: false,
              fn: function (divRow, that) {
                dbnChange(divRow, that)
              }
            }
          }
        ]
      },
      {
        headerName: 'Block',
        colWidth: '60px',
        DOMs: [
          {
            options: {
              type: 'span',
              classes: [],
              attributes: [['data-name', 'block']],
              style: [['min-width', 60]]
            },
            update: {
              numeric: true,
              fn: null
            }
          }
        ]
      },
      {
        headerName: 'Batch',
        colWidth: '60px',
        DOMs: [
          {
            options: {
              type: 'input',
              classes: ['inputBatch', 'updateDBvlaue'],
              attributes: [['data-name', 'epoxyBatch'], ['type', 'text']],
              style: [['min-width', 60]]
            },
            update: {
              numeric: false,
              fn: function (divRow, that) {
                updateThisDBValue(divRow, that, -1)
              }
            }
          }
        ]
      },
      {
        headerName: 'Resin Mass (g)',
        colWidth: '60px',
        DOMs: [
          {
            options: {
              type: 'input',
              classes: ['inputResinMass', 'updateDBvlaue'],
              attributes: [['data-name', 'resinMass'], ['type', 'text']],
              style: [['min-width', 100]]
            },
            update: {
              numeric: true,
              fn: function (divRow, that) {
                updateThisDBValue(divRow, that, -1)
              }
            }
          }
        ]
      },
      {
        headerName: 'Hardener Mass (g)',
        colWidth: '60px',
        DOMs: [
          {
            options: {
              type: 'input',
              classes: ['inputHardenerMass', 'updateDBvlaue'],
              attributes: [['data-name', 'hardenerMass'], ['type', 'text']],
              style: [['min-width', 120]]
            },
            update: {
              numeric: true,
              fn: function (divRow, that) {
                updateThisDBValue(divRow, that, -1)
              }
            }
          }
        ]
      },
      {
        headerName: 'Potting Notes',
        colWidth: '60px',
        DOMs: [
          {
            options: {
              type: 'input',
              classes: ['inputPottingNotes', 'updateDBvlaue'],
              attributes: [['data-name', 'pottingNotes'], ['type', 'text']],
              style: [['min-width', 100]]
            },
            update: {
              numeric: false,
              fn: function (divRow, that) {
                updateThisDBValue(divRow, that, -1)
              }
            }
          }
        ]
      },
      {
        headerName: 'Filling Time (min)',
        colWidth: '60px',
        DOMs: [
          {
            options: {
              type: 'input',
              classes: ['updateDBvlaue'],
              attributes: [['data-name', 'epoxyFillingTime'], ['type', 'text']],
              style: [['min-width', 80]]
            },
            update: {
              numeric: true,
              fn: function (divRow, that) {
                updateThisDBValue(divRow, that, -1)
              }
            }
          }
        ]
      },
      {
        headerName: 'Filling Date',
        colWidth: '60px',
        DOMs: [
          {
            options: {
              type: 'input',
              classes: ['inputDate', 'updateDBvlaue'],
              attributes: [['data-name', 'epoxyFillingDate'], ['type', 'text']],
              style: [['min-width', 80]]
            },
            update: {
              numeric: false,
              fn: function (divRow, that) {
                updateThisDBValue(divRow, that, -1)
              }
            }
          }
        ]
      },
      {
        headerName: 'Preparer Initials',
        colWidth: '60px',
        DOMs: [
          {
            options: {
              type: 'input',
              classes: ['inputPreparer', 'updateDBvlaue'],
              attributes: [['data-name', 'epoxyPreparer'], ['type', 'text']],
              style: [['min-width', 100]]
            },
            update: {
              numeric: false,
              fn: function (divRow, that) {
                updateThisDBValue(divRow, that, -1)
              }
            }
          }
        ]
      }
    ]
    const densityConfig = [
      {
        headerName: 'DBN',
        colWidth: '60px',
        DOMs: [
          {
            options: {
              type: 'input',
              classes: [],
              attributes: [['data-name', 'dbn'], ['type', 'text']],
              style: [['min-width', 60]]
            },
            update: {
              numeric: false,
              fn: function (divRow, that) {
                dbnChange(divRow, that)
              }
            }
          }
        ]
      },
      {
        headerName: 'Block',
        colWidth: '60px',
        DOMs: [
          {
            options: {
              type: 'span',
              classes: [],
              attributes: [['data-name', 'block']],
              style: [['min-width', 60]]
            },
            update: {
              numeric: true,
              fn: null
            }
          }
        ]
      },
      {
        headerName: 'L (in)',
        colWidth: '60px',
        DOMs: [
          {
            options: {
              type: 'input',
              classes: ['updateDBvlaue'],
              attributes: [['data-name', 'l'], ['type', 'text']],
              style: [['min-width', 60]]
            },
            update: {
              numeric: true,
              fn: function (divRow, that) {
                updateThisDBValue(divRow, that, 4)
              }
            }
          }
        ],
        append: defaultGradeSpan,
        calculation: {
          hasData: getDevHasData('l'),
          noData: devNoData
        }
      },
      {
        headerName: 'BT (in)',
        colWidth: '60px',
        DOMs: [
          {
            options: {
              type: 'input',
              classes: ['updateDBvlaue'],
              attributes: [['data-name', 'bt'], ['type', 'text']],
              style: [['min-width', 60]]
            },
            update: {
              numeric: true,
              fn: function (divRow, that) {
                updateThisDBValue(divRow, that, 4)
              }
            }
          }
        ],
        append: defaultGradeSpan,
        calculation: {
          hasData: getDevHasData('bt'),
          noData: devNoData
        }
      },
      {
        headerName: 'BB (in)',
        colWidth: '60px',
        DOMs: [
          {
            options: {
              type: 'input',
              classes: ['updateDBvlaue'],
              attributes: [['data-name', 'bb'], ['type', 'text']],
              style: [['min-width', 60]]
            },
            update: {
              numeric: true,
              fn: function (divRow, that) {
                updateThisDBValue(divRow, that, 4)
              }
            }
          }
        ],
        append: defaultGradeSpan,
        calculation: {
          hasData: getDevHasData('bb'),
          noData: devNoData
        }
      },
      {
        headerName: 'BH (in)',
        colWidth: '60px',
        DOMs: [
          {
            options: {
              type: 'input',
              classes: ['updateDBvlaue'],
              attributes: [['data-name', 'bh'], ['type', 'text']],
              style: [['min-width', 60]]
            },
            update: {
              numeric: true,
              fn: function (divRow, that) {
                updateThisDBValue(divRow, that, 4)
              }
            }
          }
        ],
        append: defaultGradeSpan,
        calculation: {
          hasData: getDevHasData('bh'),
          noData: devNoData
        }
      },
      {
        headerName: 'ST (in)',
        colWidth: '60px',
        DOMs: [
          {
            options: {
              type: 'input',
              classes: ['updateDBvlaue'],
              attributes: [['data-name', 'st'], ['type', 'text']],
              style: [['min-width', 60]]
            },
            update: {
              numeric: true,
              fn: function (divRow, that) {
                updateThisDBValue(divRow, that, 4)
              }
            }
          }
        ],
        append: defaultGradeSpan,
        calculation: {
          hasData: getDevHasData('st'),
          noData: devNoData
        }
      },
      {
        headerName: 'SB (in)',
        colWidth: '60px',
        DOMs: [
          {
            options: {
              type: 'input',
              classes: ['updateDBvlaue'],
              attributes: [['data-name', 'sb'], ['type', 'text']],
              style: [['min-width', 60]]
            },
            update: {
              numeric: true,
              fn: function (divRow, that) {
                updateThisDBValue(divRow, that, 4)
              }
            }
          }
        ],
        append: defaultGradeSpan,
        calculation: {
          hasData: getDevHasData('sb'),
          noData: devNoData
        }
      },
      {
        headerName: 'SH (in)',
        colWidth: '60px',
        DOMs: [
          {
            options: {
              type: 'input',
              classes: ['updateDBvlaue'],
              attributes: [['data-name', 'sh'], ['type', 'text']],
              style: [['min-width', 60]]
            },
            update: {
              numeric: true,
              fn: function (divRow, that) {
                updateThisDBValue(divRow, that, 4)
              }
            }
          }
        ],
        append: defaultGradeSpan,
        calculation: {
          hasData: getDevHasData('sh'),
          noData: devNoData
        }
      },
      {
        headerName: 'Volume',
        colWidth: '60px',
        DOMs: [
          {
            options: {
              type: 'span',
              classes: [],
              attributes: [['data-name', 'volume']],
              style: [['min-width', 60]]
            },
            update: {
              numeric: true,
              fn: null
            }
          }
        ],
        calculation: {
          hasData: function (index, rowData, block) {
            const densitySpan = rowData[densitySettings.properties.density]
            const densityGradeSpan = $(densitySpan).parent().children('span.gradeSpan')
            const blockDimensions = [block.l, block.bt, block.bb, block.bh, block.st, block.sb, block.sh]
            const inputDimensions = [
              rowData[densitySettings.properties.l].value,
              rowData[densitySettings.properties.bt].value,
              rowData[densitySettings.properties.bb].value,
              rowData[densitySettings.properties.bh].value,
              rowData[densitySettings.properties.st].value,
              rowData[densitySettings.properties.sb].value,
              rowData[densitySettings.properties.sh].value
            ]
            const useDimensions = []
            for (let i = 0; i < inputDimensions.length; i++) {
              const inputValue = inputDimensions[i]
              if (inputValue !== '' && !isNaN(inputValue)) {
                useDimensions.push(Number(inputValue))
              } else {
                useDimensions.push(blockDimensions[i])
              }
            }
            if (useDimensions.every((element) => element != null)) {
              const vol = getVolume(useDimensions)
              const inputMass = rowData[densitySettings.properties.mass].value
              const mass = inputMass !== '' && !isNaN(inputMass) ? Number(inputMass) : block.mass
              let density
              if (mass != null) { density = mass / vol }
              if (density != null) {
                densitySpan.innerHTML = density.toFixed(2)
                densityGradeSpan.replaceWith(getGradeSpan(grade_density(density)))
              } else {
                densitySpan.innerHTML = ''
                densityGradeSpan.replaceWith(defaultGradeSpan)
              }
              // grade these and display checkmark or something like that (don't make the colors confusing..)
              // (see info station for checkmarks, etc)
              rowData[index].innerHTML = vol.toFixed(1)
            } else {
              rowData[index].innerHTML = ''
              densitySpan.innerHTML = ''
              densityGradeSpan.replaceWith(defaultGradeSpan)
            }
          },
          noData: function (index, rowData, block) {
            const densitySpan = rowData[densitySettings.properties.density]
            const densityGradeSpan = $(densitySpan).parent().children('span.gradeSpan')
            rowData[index].innerHTML = ''
            densitySpan.innerHTML = ''
            densityGradeSpan.replaceWith(defaultGradeSpan)
          }
        }
      },
      {
        headerName: 'Density (g/mL)',
        colWidth: '60px',
        DOMs: [
          {
            options: {
              type: 'span',
              classes: [],
              attributes: [['data-name', 'density']],
              style: [['min-width', 60]]
            },
            update: {
              numeric: true,
              fn: null
            }
          }
        ],
        append: defaultGradeSpan
      },
      {
        headerName: 'Tester Initials',
        colWidth: '60px',
        DOMs: [
          {
            options: {
              type: 'input',
              classes: ['inputTester', 'updateDBvlaue'],
              attributes: [['data-name', 'dimensionTester'], ['type', 'text']],
              style: [['min-width', 60]]
            },
            update: {
              numeric: false,
              fn: function (divRow, that) {
                updateThisDBValue(divRow, that, -1)
              }
            }
          }
        ]
      },
      {
        headerName: 'Mass (g)',
        colWidth: '60px',
        DOMs: [
          {
            options: {
              type: 'input',
              classes: ['updateDBvlaue'],
              attributes: [['data-name', 'mass'], ['type', 'text']],
              style: [['min-width', 60]]
            },
            update: {
              numeric: true,
              fn: function (divRow, that) {
                updateThisDBValue(divRow, that, -1)
              }
            }
          }
        ]
      },
      {
        headerName: 'Tester Initials',
        colWidth: '60px',
        DOMs: [
          {
            options: {
              type: 'input',
              classes: ['inputTester', 'updateDBvlaue'],
              attributes: [['data-name', 'massTester'], ['type', 'text']],
              style: [['min-width', 60]]
            },
            update: {
              numeric: false,
              fn: function (divRow, that) {
                updateThisDBValue(divRow, that, -1)
              }
            }
          }
        ]
      },
      {
        headerName: 'Date',
        colWidth: '60px',
        DOMs: [
          {
            options: {
              type: 'input',
              classes: ['inputDate', 'updateDBvlaue'],
              attributes: [['data-name', 'densityDate'], ['type', 'text']],
              style: [['min-width', 80]]
            },
            update: {
              numeric: false,
              fn: function (divRow, that) {
                updateThisDBValue(divRow, that, -1)
              }
            }
          }
        ]
      }
    ]
    const tungstenRows = []
    const epoxyRows = []
    const densityRows = []
    const tungstenSettings = {
      config: tungstenConfig,
      table: $('#tungstenGridTable'),
      rows: tungstenRows,
      name: 'tungsten'
    }
    const epoxySettings = {
      config: epoxyConfig,
      table: $('#epoxyGridTable'),
      rows: epoxyRows,
      name: 'epoxy'
    }
    const densitySettings = {
      config: densityConfig,
      table: $('#densityGridTable'),
      rows: densityRows,
      name: 'density'
    }
    /*
    add as DOM config for each column, then iterate through them in addRows and in keyup
    this should be a blueprint for how to build each cell (what goes in the div) and how to update values

    hasData and noData translate to "what to do on keyup and a block is found" and "what to do on keyup and a block is not found"
    perhaps it would be better to do individual keyup functions...but then we would need to define a DBN keyup for EACH column
    (what to do when the DBN input is changed) (though most of these could be the same (just change placeholder))
    then volume, density need to change on any dim keyup (and mass too, for density)
    could define in each column:
    - what fn to call when I am keyed up
    - what columns I depend on, and what functions to call when each of these are keyed up (THE MORE LIKELY)

    ^ would the second option be the best / most robust?
    would we ever need the prior?

    then, of course, we could define self-dependence (for grading)

    ...what's the best way to keyup (iterate through these properties?)
    we would need to reverse these (do on load) and for each column, add keyups of the columns that depend on THIS column
    ... that coul work...

    */

    const allSettings = [tungstenSettings, epoxySettings, densitySettings]
    let currentDate
    let database
    const headers = []
    const sheetNames = ['Blocks DB', 'Blocks1364DB']
    let blocksCollection
    let lastDatabaseLoad
    let reloadDatabaseTimer
    let selectedSection
    let blockPropertyToCellIndex
    function doOnload () {
      function getDatabaseOnLoad () {
        currentDate = new Date()
        document.getElementById('loadingDatabase').style.display = 'block'
        google.script.run.withSuccessHandler(onSuccess).withFailureHandler(onFailure).getDatabase()
        function onSuccess (gotDatabase) {
          lastDatabaseLoad = new Date()
          updateTimestamp()
          $('#timestamp').css('display', 'block')
          console.log('loaded database in ' + (Date.now() - currentDate.getTime()) / 1000 + ' s')
          database = [gotDatabase.sheet1, gotDatabase.sheet2]
          const blocks = []
          headers[0] = database[0][0]
          for (let i = 1; i < database[0].length; i++) {
            if (database[0][i][columns.block] !== '' && !isNaN(database[0][i][columns.block])) {
              blocks.push(new Block(database[0][i], 0, i + 1, blocks.length))
            }
          }
          headers[1] = database[1][0]
          for (let i = 1; i < database[1].length; i++) {
            if (database[1][i][columns.block] !== '' && !isNaN(database[1][i][columns.block])) {
              blocks.push(new Block(database[1][i], 1, i + 1, blocks.length))
            }
          }
          blocksCollection = new BlocksCollection(blocks)
          document.getElementById('loadingDatabase').style.display = 'none'
          document.getElementById('sectionSelection').style.display = 'block'
          selectedSection = 'sectionSelection'
          setupGridTables()
          addRowByConfig(tungstenSettings, 8)
          addRowByConfig(epoxySettings, 8)
          addRowByConfig(densitySettings, 8)
        }
        function onFailure (err) {
          console.error('failed to load database...retrying in 10 seconds')
          window.setTimeout(getDatabaseOnLoad, 10 * 1000)
          throw err
        }
        $('input.batchDateUS').val(dateToUS(currentDate))
        $('input.batchDate').val(dateToYYYYMMDD(currentDate))
      }
      try {
        getDatabaseOnLoad()
      } catch (err) {
        console.error('unexpected error while getting database...retrying in 10 seconds')
        window.setTimeout(getDatabaseOnLoad, 10 * 1000)
        // throw (err)
      }
    }
    function setupGridTables () {
      for (const tableSettings of allSettings) {
        addHeaders(tableSettings)
      }
      function addHeaders (tableSettings) {
        let template = ''
        for (const columnConfig of tableSettings.config) {
          tableSettings.table.append($('<div>' + columnConfig.headerName + '</div>').addClass('gridTableHeader'))
          template += '1' + 'fr '// columnConfig.width + 'fr '
        }
        tableSettings.table.css('grid-template-columns', template).css('margin-top', '1em')
      }
    }
    function addRowByConfig (tableSettings, count) {
      const rows = tableSettings.rows
      const table = tableSettings.table
      const tableConfig = tableSettings.config
      const numRows = Math.floor(table.children('div.gridData').length / tableConfig.length)
      for (let i = 0; i < count; i++) {
        const row = []
        const rowNum = numRows + i
        for (const config of tableConfig) {
          const div = $('<div/>').addClass('gridData').attr('data-row', rowNum)
          for (const dom of config.DOMs) {
            const element = $('<' + dom.options.type + '/>')
            for (const pair of dom.options.attributes) {
              element.attr(pair[0], pair[1])
            }
            for (const pair of dom.options.style) {
              element.css(pair[0], pair[1])
            }
            for (const cls of dom.options.classes) {
              element.addClass(cls)
            }
            if (dom.options.innerHTML != null) { element.html(dom.options.innerHTML) }
            if (dom.update.fn != null) { element.keyup(function () { dom.update.fn(rows[rowNum], this) }) }
            div.append(element)
          }
          row.push(div)
        }
        table.append(row)
        const rowData = table.find('[data-row="' + (numRows + i) + '"]').toArray()
        rows.push(rowData)
      }
    }
    function generalKeyup (tableSettings, rowNum) {
      const tableConfig = tableSettings.config
      const properties = tableSettings.properties
      const rowData = tableSettings.rows[rowNum]
      const dbn = rowData[properties.dbn].value
      const block = blocksCollection.getBlockByStringDBN(dbn)
      const toUpdate = []
      for (let i = 0; i < tableConfig.length; i++) {
        if (tableConfig[i].update) {
          toUpdate.push({ element: rowData[i], config: tableConfig[i] })
        }
      }
      if (dbn !== '' && block != null) {
        // found a block, enable inputs and import data
        toUpdate.forEach(function (obj) {
          obj.element.disabled = false
          obj.element.style.backgroundColor = 'transparent'
          if (obj.config.toFixed != null && block[obj.config.propertyName] != null) {
            updateTextInput(obj.element, block[obj.config.propertyName].toFixed(obj.config.toFixed))
          } else {
            updateTextInput(obj.element, block[obj.config.propertyName])
          }
        })
        for (let i = 0; i < tableConfig.length; i++) {
          if (tableConfig[i].calculation != null) {
            tableConfig[i].calculation.hasData(i, rowData, block)
          }
        }
      } else {
        // no dbn found, disable all inputs
        toUpdate.forEach(function (obj) {
          obj.element.value = ''
          obj.element.placeholder = ''
          obj.element.disabled = true
          obj.element.style.border = '1px solid grey'
          obj.element.style.backgroundColor = '#eee'
        })
        for (let i = 0; i < tableConfig.length; i++) {
          if (tableConfig[i].calculation != null) {
            tableConfig[i].calculation.noData(i, rowData, block)
          }
        }
      }
    }
    // this is quite an elegant function - I like it
    function batchInput (form, className) {
      const grid = $(form).parent('section').children('div.grid').eq(0)
      const inputVal = $(form).children('input').eq(0).val()
      grid.find('div.gridData > input.' + className).filter(':enabled').val(inputVal).keyup()
    }
    function loadTungsten () {
      document.getElementById('sectionSelection').style.display = 'none'
      document.getElementById('tungstenSection').style.display = 'block'
      selectedSection = 'tungstenSection'
    }
    function loadEpoxy () {
      document.getElementById('sectionSelection').style.display = 'none'
      document.getElementById('epoxySection').style.display = 'block'
      selectedSection = 'epoxySection'
    }
    function loadDensity () {
      document.getElementById('sectionSelection').style.display = 'none'
      document.getElementById('densitySection').style.display = 'block'
      selectedSection = 'densitySection'
    }
    function sectionReturn () {
      $('.dataEntrySection').css('display', 'none')
      document.getElementById('sectionSelection').style.display = 'block'
      selectedSection = 'sectionSelection'
    }
    function onLogBlock () {
      const blockName = document.getElementById('logBlockInput').value
      const start = Date.now()
      const block = blocksCollection.getBlockByStringDBN(blockName)
      if (block != null) {
        // google.script.run.withSuccessHandler(onSuccess).withFailureHandler(onFailure).getRowData([{sheet: block.sheet, row: block.row}])
        console.log(block)
      } else {
        console.log("unable to locate that DBN (here's where I would offer you an option to refresh the database for another opportunity to find that block)")
      }
      function onSuccess (data) {
        const blockData = data[0]
        if (blockData != null) {
          console.log('found that block in ' + (Date.now() - start) / 1000 + ' s')
          console.log(blockData)
        } else {
          console.log('unable to locate that block')
        }
      }
      function onFailure (err) {
        alert('The server encountered an uncaught error while logging block:\n' + JSON.stringify(err))
        throw err
      }
    }
    function generalSubmitData (tableSettings) {
      const blocks = []
      const values = []
      const columnNames = []
      const rows = tableSettings.rows
      for (const row of rows) {
        const stringDBN = row[tableSettings.properties.dbn].value
        if (stringDBN !== '') {
          const block = blocksCollection.getBlockByStringDBN(stringDBN)
          if (block != null) {
            blocks.push(block)
            const blockValues = []
            for (let i = 0; i < tableSettings.config.length; i++) {
              const columnConfig = tableSettings.config[i]
              if (columnConfig.input && columnConfig.update) {
                let _set = row[i].value
                if (_set !== '') {
                  let _expected = block[columnConfig.propertyName]
                  if (_expected == null) { _expected = '' }
                  // cast set value to num if needed
                  if (columnConfig.numeric && _set !== '' && !isNaN(_set)) {
                    _set = Number(_set)
                  }
                  blockValues.push({ set: _set, expected: _expected, ignoreError: false })
                } else {
                  blockValues.push(null)
                }
                columnNames.push(columnConfig.propertyName)
              }
            }
            values.push(blockValues)
          } else {
            console.error('unable to find DBN ' + stringDBN + ' (I could offer to refresh database here)')
          }
        }
      }
      submitData(blocks, columnNames, values)
    }
    
    /**
     * submits data to the database
     * @param {Block[]} blocks Array of blocks
     * @param {String[]} columnNames Names of columns (which correspond to the columns in values)
     * @param {String[][]} values Values to submit to the database (row corresponds to blocks, column corresponds to columnNames)
     */
    function submitData (blocks, columnNames, values) {
      // first, organize data to send to the google script
      const data = []
      const cols = []
      for (const name of columnNames) {
        cols.push(columns[name])
      }
      for (let i = 0; i < blocks.length; i++) {
        const block = blocks[i]
        const blockData = {}
        blockData.expectedDBN = block.dbn
        blockData.sheet = block.sheet
        blockData.row = block.row
        blockData.cols = []
        blockData.values = []
        for (let j = 0; j < values[i].length; j++) {
          if (values[i][j] != null) {
            blockData.cols.push(cols[j])
            blockData.values.push(values[i][j])
          }
        }
        data.push(blockData)
      }
      // next, check if we know this data will overwrite existing data if submitted
      const overwriteWarnings = validateOverwrites(blocks, columnNames, values)
      if (overwriteWarnings.length !== 0) {
        // if there are overwrites, ask to confirm before proceeding
        showOverwriteWarnings(overwriteWarnings, blocks, columnNames, values, data)
      } else {
        // if not, proceed to perform basic data validation before sending to google script
        const basicDataValidationWarnings = validateData(blocks, columnNames, values)
        if (basicDataValidationWarnings.length !== 0) {
          showWarnings(basicDataValidationWarnings, data)
        } else {
          // submit to the google script
          $('#' + selectedSection).css('display', 'none')
          $('#submittingData').css('display', 'block')
          google.script.run.withSuccessHandler(onSubmitDataSuccess).withFailureHandler(onFailure).setBlockData(data)
        }
      }
    
      function validateOverwrites (blocks, columnNames, values) {
        const warnings = []
        // console.log(values)
        for (let i = 0; i < values.length; i++) {
          const block = blocks[i]
          for (let j = 0; j < columnNames.length; j++) {
            const value = values[i][j]
            // console.log(value)
            if (value !== null && value.expected !== '' && value.set != value.expected) {
              warnings.push({
                set: value.set,
                prev: value.expected,
                col: columnNames[j],
                dbn: block.dbn,
                value: value.set
              })
            }
          }
        }
        return warnings
      }
      function showOverwriteWarnings (overwriteWarnings, blocks, columnNames, values, data) {
        // console.log(data)
        let warningMsg = '(WARNING) This submission would overwrite some data in the database:\n'
        for (const warn of overwriteWarnings) {
          warningMsg += 'DBN ' + warn.dbn + ', column "' + warn.col +
            '": (warning) changing value "' + warn.prev + '" → "' + warn.set + '"\n'
        }
        warningMsg += 'Are you sure you want to submit this data to the database?'
        const bool = confirm(warningMsg)
        if (bool) {
          // overwrite was confirmed, perform basic data validation before sending to google script
          const warnings = validateData(blocks, columnNames, values)
          if (warnings.length !== 0) {
            showWarnings(warnings, data)
          } else {
            // submit to the google script
            $('#' + selectedSection).css('display', 'none')
            $('#submittingData').css('display', 'block')
            google.script.run.withSuccessHandler(onSubmitDataSuccess).withFailureHandler(onFailure).setBlockData(data)
          }
        }
      }
    
      function validateData (blocks, columnNames, values) {
        const warnings = []
        // console.log(values)
        for (let i = 0; i < values.length; i++) {
          const block = blocks[i]
          for (let j = 0; j < columnNames.length; j++) {
            const value = values[i][j]
            // console.log(value)
            if (value != null && Object.prototype.hasOwnProperty.call(validate, columnNames[j])) {
              const validation = validate[columnNames[j]](value.set)
              if (!validation.valid) {
                warnings.push({
                  msg: validation.msg,
                  col: columnNames[j],
                  dbn: block.dbn,
                  value: value.set
                })
              }
            }
          }
        }
        return warnings
      }
      function showWarnings (warnings, data) {
        // console.log(data)
        let warningMsg = '(WARNING) Some of the data is not as expected:\n'
        for (const warn of warnings) {
          warningMsg += 'DBN ' + warn.dbn + ', column "' + warn.col +
            '": (warning) for value "' + warn.value + '", ' + warn.msg + '\n'
        }
        warningMsg += 'Are you sure you want to submit this data to the database?'
        const bool = confirm(warningMsg)
        if (bool) {
          $('#' + selectedSection).css('display', 'none')
          $('#submittingData').css('display', 'block')
          google.script.run.withSuccessHandler(onSubmitDataSuccess).withFailureHandler(onFailure).setBlockData(data)
        }
      }
    
      function showErrorAlert (msg, data) {
        if (msg.unexpectedDBNError !== undefined) {
          const errorMsg = '(ERROR) Encountered an unexpected DBN (did a DBN change? were rows added or deleted?):\n' +
            'In sheet ' + sheetNames[msg.unexpectedDBNError.loc.sheet] + ', row ' + msg.unexpectedDBNError.loc.row +
            ', expected DBN ' + msg.unexpectedDBNError.expectedDBN + ', but found DBN ' + msg.unexpectedDBNError.foundDBN + '\n' +
            'Try refreshing the database and resubmitting (or Mason needs to fix something)'
          $('#' + selectedSection).css('display', 'block')
          $('#submittingData').css('display', 'none')
          alert(errorMsg)
        } else if (msg.dataValidationErrors.length !== 0 || msg.unexpectedValueErrors.length !== 0) {
          let errorMsg = ''
          const fatalErrors = []
          for (const error of msg.dataValidationErrors) {
            if (error.fatal) {
              fatalErrors.push(error)
            }
          }
          if (fatalErrors.length !== 0) {
            // show an alert: UNABLE to submit this data because these errors (the fatal errors)
            errorMsg += '(ERROR) Unable to submit data to the database due to these data validation errors:\n'
            for (const error of fatalErrors) {
              const dbn = blocksCollection.getBlockByLocation(error.loc.sheet, error.loc.row).dbn
              if (error.type === 'VALUE_IN_LIST') {
                errorMsg += 'In sheet ' + sheetNames[error.loc.sheet] + ', DBN ' + dbn +
                  ' (row ' + error.loc.row + '), column "' + (headers[error.loc.sheet][error.loc.col]) +
                  '": tried to write value "' + error.value + '" but cell requires a value in ' + JSON.stringify(error.args[0]) + '\n'
              } else if (error.type === 'DATE_IS_VALID_DATE') {
                errorMsg += 'In sheet ' + sheetNames[error.loc.sheet] + ', DBN ' + dbn +
                  ' (row ' + error.loc.row + '), column "' + (headers[error.loc.sheet][error.loc.col]) +
                  '": tried to write value "' + error.value + '" but cell requires a valid date\n'
              } else {
                errorMsg += 'In sheet ' + sheetNames[error.loc.sheet] + ', DBN ' + dbn +
                  ' (row ' + error.loc.row + '), column "' + (headers[error.loc.sheet][error.loc.col]) +
                  '": unknown data validation type (' + error.type + ') at value "' + error.value + '": ' + JSON.stringify(error.args[0]) + '\n'
                errorMsg += JSON.stringify(error) + '\n'
              }
            }
            $('#' + selectedSection).css('display', 'block')
            $('#submittingData').css('display', 'none')
            alert(errorMsg)
          } else {
            // no fatal errors, show warnings and ask to confirm
            if (msg.dataValidationErrors.length !== 0) {
              errorMsg += '(WARNING) Encountered the following unchecked data validation warnings while trying to write to the database:\n'
              for (const error of msg.dataValidationErrors) {
                const dbn = blocksCollection.getBlockByLocation(error.loc.sheet, error.loc.row).dbn
                if (error.type === 'VALUE_IN_LIST') {
                  errorMsg += 'In sheet ' + sheetNames[error.loc.sheet] + ', DBN ' + dbn +
                    ' (row ' + error.loc.row + '), column "' + (headers[error.loc.sheet][error.loc.col]) +
                    '": tried to write value "' + error.value + '" but cell suggests a value in ' + JSON.stringify(error.args[0]) + '\n'
                } else if (error.type === 'DATE_IS_VALID_DATE') {
                  errorMsg += 'In sheet ' + sheetNames[error.loc.sheet] + ', DBN ' + dbn +
                    ' (row ' + error.loc.row + '), column "' + (headers[error.loc.sheet][error.loc.col]) +
                    '": tried to write value "' + error.value + '" but cell suggests a valid date\n'
                } else {
                  errorMsg += 'In sheet ' + sheetNames[error.loc.sheet] + ', DBN ' + dbn +
                    ' (row ' + error.loc.row + '), column "' + (headers[error.loc.sheet][error.loc.col]) +
                    '": encountered an unknown data validation type (' + error.type + ') for value "' + error.value + '": ' + JSON.stringify(error.args[0]) + '\n'
                  errorMsg += JSON.stringify(error) + '\n'
                }
              }
            }
            if (msg.unexpectedValueErrors.length !== 0) {
              errorMsg += '(WARNING) Found the following unexpected values in the database (did these cells change since this page was loaded?):\n'
              for (const error of msg.unexpectedValueErrors) {
                const dbn = blocksCollection.getBlockByLocation(error.loc.sheet, error.loc.row).dbn
                errorMsg += 'In sheet ' + sheetNames[error.loc.sheet] + ', DBN ' + dbn +
                  ' (row ' + error.loc.row + '), column "' + (headers[error.loc.sheet][error.loc.col]) +
                  '": expected value "' + error.expected + '" but found "' + error.found + '"\n'
              }
            }
            errorMsg += 'Press OK to ignore these errors and submit this data to the database'
            const bool = confirm(errorMsg)
            if (bool) {
              for (const error of msg.dataValidationErrors.concat(msg.unexpectedValueErrors)) {
                const i = error.id[0]
                const j = error.id[1]
                data[i].values[j].ignoreError = true
              }
              google.script.run.withSuccessHandler(onSubmitDataSuccess).withFailureHandler(onFailure).setBlockData(data)
            } else {
              $('#' + selectedSection).css('display', 'block')
              $('#submittingData').css('display', 'none')
            }
          }
        } else {
          $('#' + selectedSection).css('display', 'block')
          $('#submittingData').css('display', 'none')
          const successMsg = 'Successfully wrote data to the database'
          alert(successMsg)
        }
      }
      function onSubmitDataSuccess (msg) {
        // console.log(msg)
        showErrorAlert(msg, data)
        updateBlocks(msg.newBlockData)
      }
      function onFailure (err) {
        alert('The server encountered an uncaught error while submitting data:\n' + JSON.stringify(err))
        throw err
      }
    }
    
    function updateDatabase () {
      const start = Date.now()
      document.getElementById('loadingDatabase').style.display = 'block'
      $('.hideWhenLoading').css('display', 'none')
      // console.log([$('#sectionSelection').css('display'), $('#tungstenSection').css('display'), $('#epoxySection').css('display'), $('#densitySection').css('display')])
      google.script.run.withSuccessHandler(onSuccess).withFailureHandler(onFailure).getDatabase()
      function onSuccess (sheets) {
        lastDatabaseLoad = new Date()
        console.log('loaded database in ' + (Date.now() - start) / 1000 + ' s')
        updateTimestamp()
        database = [sheets.sheet1, sheets.sheet2]
        const blocks = []
        headers[0] = database[0][0]
        for (let i = 1; i < database[0].length; i++) {
          if (database[0][i][columns.block] !== '' && !isNaN(database[0][i][columns.block])) {
            blocks.push(new Block(database[0][i], 0, i + 1, blocks.length))
          }
        }
        headers[1] = database[1][0]
        for (let i = 1; i < database[1].length; i++) {
          if (database[1][i][columns.block] !== '' && !isNaN(database[1][i][columns.block])) {
            blocks.push(new Block(database[1][i], 1, i + 1, blocks.length))
          }
        }
        blocksCollection = new BlocksCollection(blocks)
        document.getElementById('loadingDatabase').style.display = 'none'
        $('#' + selectedSection).css('display', 'block')
        updateTables()
      }
      function onFailure (err) {
        alert('The server encountered an uncaught error while refreshing database:\n' + JSON.stringify(err))
        throw err
      }
    }
    function updateBlocks (blockData) {
      if (blockData != null) {
        const rowData = blockData.rowData
        const sheets = blockData.sheets
        const rows = blockData.rows
        for (let i = 0; i < rowData.length; i++) {
          blocksCollection.updateBlock(rowData[i], sheets[i], rows[i])
        }
        updateTables()
      }
    }
    function updateTables () {
      console.log('updated tables?')
      // call all keyups? ig
      /*
      for (let i = 0; i < tungstenRows.length; i++) {
        generalKeyup(tungstenSettings, i)
      }
      for (let i = 0; i < epoxyRows.length; i++) {
        generalKeyup(epoxySettings, i)
      }
      for (let i = 0; i < densityRows.length; i++) {
        generalKeyup(densitySettings, i)
      }
      */
    }
    function updateTimestamp () {
      // (re)set color/style to the normal
      const timestampDiv = $('#timestamp')
      const text = 'Database loaded: ' + String(lastDatabaseLoad)
      const p = timestampDiv.children('p')
      // console.log(p)
      p.html(text).css('color', 'black').css('font-weight', 'normal')
      window.clearTimeout(reloadDatabaseTimer)
      reloadDatabaseTimer = window.setTimeout(setRed, 5 * 1000 * 60)
      function setRed () {
        p.css('color', 'red').css('font-weight', 'bold')
        alert('The script is using data which is at least 5 minutes old. Consider refreshing the database.')
      }
    }
  </script>
</html>
