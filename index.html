<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NPL Data Entry</title>
    <link rel="stylesheet" href="https://ssl.gstatic.com/docs/script/css/add-ons1.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>
    <?!= include('css')?>
  </head>
  <body onload="doOnload()" style="margin: 1em;">
    <div class="header" style="display: block; padding: 1em; overflow: auto;">
      <img src="https://drive.google.com/uc?id=1JLX7vfDnqgYd_OrgPNtvj1sqV8n4ANpd"/>
      <h1>NPL Data Entry</h1>
    </div>
    <div id="loadingDatabase" style="display: none;">Loading Database...</div>
    <div id="sectionSelection" style="display: none;">
      <button onclick="loadTungsten()">Tungsten</button>
      <button onclick="loadEpoxy()">Epoxy</button>
      <button onclick="loadDensity()">Density</button>
      <section style="display: inline-block; margin-top: 1em;">
        <form action="javascript:onLogBlock()" style="display: none;">
          <label>log block: </label><input type="text" id="logBlockInput">
          <button id="logBlockButton">submit</button>
        </form>
		  </section>
    </div>
    <section id="tungstenSection" class="dataEntrySection" style="display: none;">
      <button onclick="sectionReturn()">Back</button>
      <button onclick="submitTungstenData()">SUBMIT</button><br>
      <form action="javascript:" onsubmit="batchInput(this, 'inputPowder')" style="margin-top: 1em; display: block;">
        <label style="font-weight: bold; width: 120px; display: inline-block;">Powder: </label><input type="text" style="width: 80px;">
        <button style="margin-left: 1em">Submit</button>
      </form>
      <form action="javascript:" onsubmit="batchInput(this, 'inputBucket')" style="margin-top: 1em; display: block;">
        <label style="font-weight: bold; width: 120px; display: inline-block;">Bucket #: </label><input type="text" style="width: 80px;">
        <button style="margin-left: 1em">Submit</button>
      </form>
      <form action="javascript:" onsubmit="batchInput(this, 'inputDate')" style="margin-top: 1em; display: block;">
        <label style="font-weight: bold; width: 120px; display: inline-block;">Date: </label><input type="text" class="batchDateUS" style="width: 80px;">
        <button style="margin-left: 1em">Submit</button>
      </form>
      <form action="javascript:" onsubmit="batchInput(this, 'inputFiller')" style="margin-top: 1em; display: block;">
        <label style="font-weight: bold; width: 120px; display: inline-block;">Filler Initials: </label><input type="text" style="width: 80px;">
        <button style="margin-left: 1em">Submit</button>
      </form>
      <div id="tungstenGridTable" class="grid"></div>
      <button onclick="addRow('tungstenSection', 1)" style="margin-top: 1em;">Add Row</button>
    </section>
    <section id="epoxySection" class="dataEntrySection" style="display: none;">
      <button onclick="sectionReturn()">Back</button>
      <button onclick="submitEpoxyData()">SUBMIT</button><br>
      <form action="javascript:" onsubmit="batchInput(this, 'inputBatch')" style="margin-top: 1em; display: block;">
        <label style="font-weight: bold; width: 120px; display: inline-block;">Epoxy Batch: </label><input type="text" style="width: 80px;">
        <button style="margin-left: 1em">Submit</button>
      </form>
      <form action="javascript:" onsubmit="batchInput(this, 'inputResinMass')" style="margin-top: 1em; display: block;">
        <label style="font-weight: bold; width: 120px; display: inline-block;">Resin Mass: </label><input type="text" style="width: 80px;">
        <button style="margin-left: 1em">Submit</button>
      </form>
      <form action="javascript:" onsubmit="batchInput(this, 'inputHardenerMass')" style="margin-top: 1em; display: block;">
        <label style="font-weight: bold; width: 120px; display: inline-block;">Hardener Mass: </label><input type="text" style="width: 80px;">
        <button style="margin-left: 1em">Submit</button>
      </form>
      <form action="javascript:" onsubmit="batchInput(this, 'inputPottingNotes')" style="margin-top: 1em; display: block;">
        <label style="font-weight: bold; width: 120px; display: inline-block;">Potting Notes: </label><input type="text" style="width: 80px;">
        <button style="margin-left: 1em">Submit</button>
      </form>
      <form action="javascript:" onsubmit="batchInput(this, 'inputDate')" style="margin-top: 1em; display: block;">
        <label style="font-weight: bold; width: 120px; display: inline-block;">Date: </label><input type="text" class="batchDateUS" style="width: 80px;">
        <button style="margin-left: 1em">Submit</button>
      </form>
      <form action="javascript:" onsubmit="batchInput(this, 'inputPreparer')" style="margin-top: 1em; display: block;">
        <label style="font-weight: bold; width: 120px; display: inline-block;">Preparer Initials: </label><input type="text" style="width: 80px;">
        <button style="margin-left: 1em">Submit</button>
      </form>
      <div id="epoxyGridTable" class="grid"></div>
      <button onclick="addRow('epoxySection', 1)" style="margin-top: 1em;">Add Row</button>
    </section>
    <section id="densitySection" class="dataEntrySection" style="display: none;">
      <button onclick="sectionReturn()">Back</button>
      <button onclick="submitDensityData()">SUBMIT</button><br>
      <form action="javascript:" onsubmit="batchInput(this, 'inputDate')" style="margin-top: 1em; display: block;">
        <label style="font-weight: bold; width: 120px; display: inline-block;">Date: </label><input type="text" class="batchDate" style="width: 80px;">
        <button style="margin-left: 1em">Submit</button>
      </form>
      <form action="javascript:" onsubmit="batchInput(this, 'inputTester')" style="margin-top: 1em; display: block;">
        <label style="font-weight: bold; width: 120px; display: inline-block;">Tester Initials: </label><input type="text" style="width: 80px;">
        <button style="margin-left: 1em">Submit</button>
      </form>
      <div id="densityGridTable" class="grid"></div>
      <button onclick="addRow('densitySection', 1)" style="margin-top: 1em;">Add Row</button>
    </section>
  </body>
  <script>
    /* global google */
    /* eslint no-undef: "error" */
    // HELPER FUNCTIONS
    function dataPresent (data) {
      return (data != null && data !== '' && data !== '#NUM!' && data !== '#DIV/0!' && data !== 'NaN')
    }
    function to2digits (string) {
      if (string.length < 2) {
        return '0' + string
      } else {
        return string
      }
    }
    function dateToYYYYMMDD (date) {
      const y = date.getFullYear().toString()
      let m = (date.getMonth() + 1).toString()
      let d = date.getDate().toString()
      if (m.length === 1) { m = '0' + m }
      if (d.length === 1) { d = '0' + d }
      return parseInt(y + m + d)
    }
    function dateToUS (date) {
      const m = (date.getMonth() + 1).toString()
      const d = (date.getDate()).toString()
      const y = (date.getFullYear()).toString()
      return m + '/' + d + '/' + y
    }
    /**
      * calculates the volume of a block
      * @param {Number[]} dimensions The dimensions of the block (in) as [l,bt,bb,bh,st,sb,sh]
      * @return {Number} The volume of the block (mL)
      */
    function getVolume (dimensions) {
      const l = dimensions[0]
      const bt = dimensions[1]
      const bb = dimensions[2]
      const bh = dimensions[3]
      const st = dimensions[4]
      const sb = dimensions[5]
      const sh = dimensions[6]
      return 16.39 * l * (1 / 2) * (((bt + bb) * bh / 2) + ((st + sb) * sh / 2))
    }
    /**
      * @param {Number}
      * @return {String}
      */
    function columnToLetter (column) {
      let temp = ''
      let letter = ''
      while (column > 0) {
        temp = (column - 1) % 26
        letter = String.fromCharCode(temp + 65) + letter
        column = (column - temp - 1) / 26
      }
      return letter
    }
    /**
      * @param {String}
      * @return {Number} the (one-based) column index
      */
    function letterToColumn (letter) {
      let column = 0
      const length = letter.length
      for (let i = 0; i < length; i++) {
        column += (letter.charCodeAt(i) - 64) * Math.pow(26, length - i - 1)
      }
      return column
    }
    // CONSTANTS
    // store the ZERO-BASED index for each column
    const columns = {
      dbn: 0,
      block: 2,
      status: 3,
      shipment: 4,
      shipmentDate: 5,
      comment: 6,
      sector: 7,
      powder: 14,
      bucket: 15,
      moldSeries: 16,
      emptyMoldMass: 17,
      filledMoldMass: 18,
      tungstenMass: 19,
      tungstenFillingDate: 21,
      tungstenFiller: 22,
      epoxyBatch: 23,
      resinMass: 24,
      hardenerMass: 25,
      pottingNotes: 26,
      epoxyFillingTime: 27,
      epoxyFillingDate: 28,
      epoxyPreparer: 29,
      machiningDate: 31,
      l: 33,
      bt: 34,
      bb: 35,
      bh: 36,
      st: 37,
      sb: 38,
      sh: 39,
      volume: 40,
      dimensionTester: 41,
      mass: 42,
      massTester: 43,
      density: 44,
      densityDate: 45,
      goodEnd: 47,
      fiberPercentage: 49,
      tower1: 55,
      tower2: 56,
      tower3: 57,
      tower4: 58,
      missingRow: 59,
      thirteenHoles: 60,
      lightTransTester: 63,
      lightTransDate: 64,
      scintillation: 65,
      scintRatio: 67,
      scintDate: 69,
      natLightDate: 70,
      natLightTester: 71,
      densityCheckedBy: 73,
      lightTransCheckedBy: 74,
      natLightCheckedBy: 75,
      pregrade: 80
    }
    // stores the expected dimensions for each block type
    // BL      L       BT      BB      BH      ST      SB      SH
    const dimensionsMap = new Map([
      [123, [5.5000, 2.0850, 2.0850, 1.9890, 1.8150, 1.8150, 1.9890]],
      [4, [5.4460, 2.0850, 2.0820, 2.2740, 1.8180, 1.8150, 1.9900]],
      [5, [5.3500, 2.0850, 2.0760, 2.2630, 1.8230, 1.8150, 1.9900]],
      [6, [5.2700, 2.0850, 2.0710, 2.2530, 1.8280, 1.8150, 1.9900]],
      [7, [5.2050, 2.0850, 2.0650, 2.2430, 1.8320, 1.8150, 1.9900]],
      [8, [5.1550, 2.0850, 2.0600, 2.2340, 1.8370, 1.8150, 1.9890]],
      [9, [5.1180, 2.0850, 2.0560, 2.2250, 1.8410, 1.8150, 1.9890]],
      [10, [5.0940, 2.0850, 2.0510, 2.2160, 1.8460, 1.8150, 1.9890]],
      [11, [5.0820, 2.0850, 2.0470, 2.2080, 1.8500, 1.8150, 1.9890]],
      [12, [5.0810, 2.0850, 2.0420, 2.2010, 1.8530, 1.8150, 1.9890]],
      [13, [5.0900, 2.0850, 2.0390, 2.1930, 1.8570, 1.8150, 1.9890]],
      [14, [5.1100, 2.0850, 2.0350, 2.1860, 1.8600, 1.8150, 1.9890]],
      [15, [5.1390, 2.0850, 2.0320, 2.1800, 1.8640, 1.8150, 1.9890]],
      [16, [5.1770, 2.0850, 2.0280, 2.1740, 1.8670, 1.8150, 1.9890]],
      [17, [5.2240, 2.0850, 2.0250, 2.1680, 1.8700, 1.8150, 1.9890]],
      [18, [5.2790, 2.0850, 2.0230, 2.1620, 1.8720, 1.8150, 1.9890]],
      [19, [5.3420, 2.0850, 2.0200, 2.1570, 1.8750, 1.8150, 1.9890]],
      [20, [5.4120, 2.0850, 2.0180, 2.1520, 1.8770, 1.8150, 1.9890]],
      [21, [5.4890, 2.0850, 2.0150, 2.1470, 1.8790, 1.8150, 1.9890]],
      [22, [5.5720, 2.0850, 2.0130, 2.1420, 1.8810, 1.8150, 1.9890]],
      [23, [5.6620, 2.0850, 2.0120, 2.1380, 1.8830, 1.8150, 1.9890]],
      [24, [5.7580, 2.0850, 2.0100, 2.1330, 1.8850, 1.8150, 1.9890]]
    ])
    // CLASS DEFINITIONS
    class Block {
      constructor (array, sheet, row, index) {
        this.sheet = sheet
        this.row = row
        this.index = index
        this.dbn = array[0]
        this.block = parseInt(array[2])
        this.status = array[3]
        this.powder = (!dataPresent(array[14])) ? null : array[14]
        this.bucket = (!dataPresent(array[15])) ? null : array[15]
        this.moldSeries = (!dataPresent(array[16])) ? null : array[16]
        this.emptyMoldMass = (!dataPresent(array[17])) ? null : parseInt(array[17])
        this.filledMoldMass = (!dataPresent(array[18])) ? null : parseInt(array[18])
        this.tungstenMass = (!dataPresent(array[19]) || parseInt(array[19]) === 0) ? null : parseInt(array[19])
        this.tungstenFillingDate = (!dataPresent(array[21])) ? null : array[21]
        this.tungstenFiller = (!dataPresent(array[22])) ? null : array[22]
        this.epoxyBatch = (!dataPresent(array[23])) ? null : parseInt(array[23])
        this.resinMass = (!dataPresent(array[24])) ? null : parseInt(array[24])
        this.hardenerMass = (!dataPresent(array[25])) ? null : parseInt(array[25])
        this.pottingNotes = (!dataPresent(array[26])) ? null : array[26]
        this.epoxyFillingTime = (!dataPresent(array[27])) ? null : parseFloat(array[27])
        this.epoxyFillingDate = (!dataPresent(array[28])) ? null : array[28]
        this.epoxyPreparer = (!dataPresent(array[29])) ? null : array[29]
        this.l = (!dataPresent(array[33])) ? null : parseFloat(array[33])
        this.bt = (!dataPresent(array[34])) ? null : parseFloat(array[34])
        this.bb = (!dataPresent(array[35])) ? null : parseFloat(array[35])
        this.bh = (!dataPresent(array[36])) ? null : parseFloat(array[36])
        this.st = (!dataPresent(array[37])) ? null : parseFloat(array[37])
        this.sb = (!dataPresent(array[38])) ? null : parseFloat(array[38])
        this.sh = (!dataPresent(array[39])) ? null : parseFloat(array[39])
        this.volume = (!dataPresent(array[40]) || parseInt(array[40]) === 0) ? null : parseFloat(array[40])
        this.dimensionTester = (!dataPresent(array[41])) ? null : array[41]
        this.mass = (!dataPresent(array[42])) ? null : parseInt(array[42])
        this.massTester = (!dataPresent(array[43])) ? null : array[43]
        this.density = (!dataPresent(array[44])) ? null : parseFloat(array[44])
        this.densityDate = (!dataPresent(array[45])) ? null : parseInt(array[45])
      }

      deviations () {
        const tols = [this.l, this.bt, this.bb, this.bh, this.st, this.sb, this.sh]
        if (tols.every((value) => value != null)) {
          const devs = []
          tols.forEach(function (value, index) { devs[index] = value - dimensionsMap.get(this.block)[index] })
          return devs
        } else {
          return null
        }
      }

      testGrades () {
        if (this.sheet === 0) {
          const devs = this.deviations()
          const devGrades = new Array(7)
          if (devs == null) {
            devGrades.fill(notStartedGrade)
          } else {
            for (let i = 0; i < devs.length; i++) {
              if (i === 0) {
                devGrades[0] = (devs[0] == null) ? notStartedGrade : grade_dL(devs[0])
              } else {
                devGrades[i] = (devs[i] == null) ? notStartedGrade : grade_otherDev(devs[i])
              }
            }
          }
          const densityValuesToGrade = [
            ((this.density == null) ? notStartedGrade : grade_density(this.density)),
            ...devGrades
          ]
          const densityGrade = Math.max(...densityValuesToGrade)
          return {
            density: densityGrade,
            tolerances: devGrades
          }
        } else {
          return null
        }
      }
    }
    class BlocksCollection {
      constructor (array) {
        this.array = array
        // console.log('new blocks collection with array length ' + array.length)
      }

      getBlockByIndex (index) {
        return this.array[index]
      }
    
      getBlockByLocation (sheet, row) {
        let index
        // shame we can't use a binary search here (string DBNs are not sorted), but it really doesn't take that long
        this.array.forEach(function (block, _index, array) {
          if (block.sheet === sheet && block.row === row) {
            index = _index
          }
        })
        if (index != null) { return this.array[index] }
      }

      getBlockByStringDBN (stringDBN) {
        let index
        // shame we can't use a binary search here (string DBNs are not sorted), but it really doesn't take that long
        this.array.forEach(function (block, _index, array) {
          if (stringDBN === block.dbn) {
            index = _index
          }
        })
        if (index != null) { return this.array[index] }
      }
    
      updateBlock (rowData, sheet, row) {
        const dbn = rowData[0]
        const block = this.getBlockByStringDBN(dbn)
        if (block != null) {
          const i = block.index
          this.array[i] = new Block(rowData, sheet, row, i)
        }
      }

      getBlocksNeedingRetouch (retouchStatus) {
        const blocks = []
        const devNames = ['L', 'BT', 'BB', 'BH', 'ST', 'SB', 'SH']
        const allowedStatuses = ['5', '5a', '5b', '5c']
        this.array.forEach(function (block) {
          if (block.deviations() != null && block.retouch === retouchStatus && allowedStatuses.includes(block.status)) {
            const retouchDevs = []
            block.deviations().forEach(function (dev, index) {
              if (index === 0) {
                if (grade_dL(dev) === fGrade && dev > 0) {
                  retouchDevs.push([devNames[index], dev])
                }
              } else if (grade_otherDev(dev) === fGrade && dev > 0) {
                retouchDevs.push([devNames[index], '+' + dev.toFixed(4)])
              }
            })
            if (retouchDevs.length > 0) {
              blocks.push([block, retouchDevs])
            }
          }
        })
        return blocks
      }
    }
    //
    // could have two types, error (don't try to submit) and warning (ask for confirmation)
    // (although these esentially do the same thing)
    //  data validation rules for input data
    const validate = {
      powder: function (data) {
        if (data === 'HCS') {
          return {
            valid: true,
            msg: null
          }
        } else {
          return {
            valid: false,
            msg: "expected 'HCS'"
          }
        }
      }, // handled by database data validation
      bucket: function (data) {
        const split = data.split('-')
        if (split.length !== 2) {
          return {
            valid: false,
            msg: "expected '-'"
          }
        } else {
          const pre = split[0]
          const suf = split[1]
          if (pre !== 'HCS') {
            return {
              valid: false,
              msg: "expected bucket to begin with 'HCS'"
            }
          } else if (isNaN(suf)) {
            return {
              valid: false,
              msg: "expected number after 'HCS'"
            }
          } else {
            return {
              valid: true,
              msg: null
            }
          }
        }
      }, // handled by database data validation
      // moldSeries: function (data) {return true}, // handled by database data validation
      emptyMoldMass: validNumber,
      filledMoldMass: validNumber,
      tungstenFillingDate: validUSDate,
      tungstenFiller: validInitials, // handled by database data validation
      epoxyBatch: validNumber, // handled by database data validation
      resinMass: validNumber, // handled by database data validation
      hardenerMass: validNumber, // handled by database data validation
      pottingNotes: function (data) {
        if (data === 'd40g') {
          return {
            valid: true,
            msg: null
          }
        } else {
          return {
            valid: false,
            msg: "expected 'd40g'"
          }
        }
      },
      epoxyFillingTime: validNumber,
      epoxyFillingDate: validUSDate,
      epoxyPreparer: validInitials, // handled by database data validation
      l: validNumber,
      bt: validNumber,
      bb: validNumber,
      bh: validNumber,
      st: validNumber,
      sb: validNumber,
      sh: validNumber,
      dimensionTester: validInitials, // should always be the same as mass tester, which is handled by database data validation
      mass: validNumber,
      massTester: validInitials, // handled by database data validation
      densityDate: validYYYYMMDD
    }
    function validNumber (str) {
      if (str !== '' && !isNaN(str)) {
        return {
          valid: true,
          msg: null
        }
      } else {
        return {
          valid: false,
          msg: 'expected a number'
        }
      }
    }
    function validUSDate (str) {
      const split = str.split('/')
      if (split.length !== 3) {
        return {
          valid: false,
          msg: "expected two /'s in US date"
        }
      }
      let m = split[0]
      let d = split[1]
      let y = split[2]
      if (isNaN(y) || isNaN(m) || isNaN(d)) {
        return {
          valid: false,
          msg: "expected numbers between /'s"
        }
      }
      y = Number(y)
      m = Number(m)
      d = Number(d)
      if (y > 2000 && m < 13 && d < 32) {
        return {
          valid: true,
          msg: null
        }
      } else {
        return {
          valid: false,
          msg: 'expected a valid US Date (month/day/year)'
        }
      }
    }
    function validInitials (str) {
      if (str.length === 2) {
        return {
          valid: true,
          msg: null
        }
      } else {
        return {
          valid: false,
          msg: 'expected initials (two characters)'
        }
      }
    }
    function validYYYYMMDD (str) {
      if (str.length !== 8) {
        return {
          valid: false,
          msg: 'expected 8 characters (YYYYMMDD)'
        }
      }
      let y = str.substr(0, 4)
      let m = str.substr(4, 2)
      let d = str.substr(6, 2)
      if (isNaN(y) || isNaN(m) || isNaN(d)) {
        return {
          valid: false,
          msg: 'expected only numberic characters'
        }
      }
      y = Number(y)
      m = Number(m)
      d = Number(d)
      if (y > 2000 && m < 13 && d < 32) {
        return {
          valid: true,
          msg: null
        }
      } else {
        return {
          valid: false,
          msg: 'expected a valid date (YYYYMMDD)'
        }
      }
    }

    // TABLE CONFIGURATIONS
    const tungstenConfig = [
      {
        headerName: 'DBN',
        propertyName: 'dbn',
        width: 1,
        minWidth: 60,
        numeric: false,
        update: false,
        input: true,
        disabled: false
      },
      {
        headerName: 'Powder',
        propertyName: 'powder',
        width: 2,
        minWidth: 60,
        numeric: false,
        update: true,
        input: true,
        disabled: true
      },
      {
        headerName: 'Bucket #',
        propertyName: 'bucket',
        width: 2,
        minWidth: 60,
        numeric: false,
        update: true,
        input: true,
        disabled: true
      },
      {
        headerName: 'Mold #',
        propertyName: 'moldSeries',
        width: 1,
        minWidth: 60,
        numeric: false,
        update: true,
        input: true,
        disabled: true
      },
      {
        headerName: 'Empty Mass (g)',
        propertyName: 'emptyMoldMass',
        width: 2,
        minWidth: 100,
        numeric: true,
        update: true,
        input: true,
        disabled: true
      },
      {
        headerName: 'Filled Mass (g)',
        propertyName: 'filledMoldMass',
        width: 2,
        minWidth: 100,
        numeric: true,
        update: true,
        input: true,
        disabled: true
      },
      {
        headerName: 'Filling Date',
        propertyName: 'tungstenFillingDate',
        width: 2,
        minWidth: 80,
        numeric: false,
        update: true,
        input: true,
        disabled: true
      },
      {
        headerName: 'Filler Initials',
        propertyName: 'tungstenFiller',
        width: 2,
        minWidth: 80,
        numeric: false,
        update: true,
        input: true,
        disabled: true
      }
    ]
    const epoxyConfig = [
      {
        headerName: 'DBN',
        propertyName: 'dbn',
        width: 1,
        minWidth: 60,
        numeric: false,
        update: false,
        input: true,
        disabled: false
      },
      {
        headerName: 'Batch',
        propertyName: 'epoxyBatch',
        width: 1,
        minWidth: 60,
        numeric: false,
        update: true,
        input: true,
        disabled: true
      },
      {
        headerName: 'Resin Mass (g)',
        propertyName: 'resinMass',
        width: 2,
        minWidth: 100,
        numeric: true,
        update: true,
        input: true,
        disabled: true
      },
      {
        headerName: 'Hardener Mass (g)',
        propertyName: 'hardenerMass',
        width: 2,
        minWidth: 120,
        numeric: true,
        update: true,
        input: true,
        disabled: true
      },
      {
        headerName: 'Potting Notes',
        propertyName: 'pottingNotes',
        width: 2,
        minWidth: 100,
        numeric: false,
        update: true,
        input: true,
        disabled: true
      },
      {
        headerName: 'Filling Time',
        propertyName: 'epoxyFillingTime',
        width: 2,
        minWidth: 80,
        numeric: true,
        update: true,
        input: true,
        disabled: true
      },
      {
        headerName: 'Filling Date',
        propertyName: 'epoxyFillingDate',
        width: 2,
        minWidth: 80,
        numeric: false,
        update: true,
        input: true,
        disabled: true
      },
      {
        headerName: 'Preparer Initials',
        propertyName: 'epoxyPreparer',
        width: 2,
        minWidth: 100,
        numeric: false,
        update: true,
        input: true,
        disabled: true
      }
    ]
    const densityConfig = [
      {
        headerName: 'DBN',
        propertyName: 'dbn',
        width: 1,
        minWidth: 60,
        numeric: false,
        update: false,
        input: true,
        disabled: false
      },
      {
        headerName: 'L (in)',
        propertyName: 'l',
        width: 1,
        minWidth: 60,
        numeric: true,
        update: true,
        input: true,
        disabled: true
      },
      {
        headerName: 'BT (in)',
        propertyName: 'bt',
        width: 1,
        minWidth: 60,
        numeric: true,
        update: true,
        input: true,
        disabled: true
      },
      {
        headerName: 'BB (in)',
        propertyName: 'bb',
        width: 1,
        minWidth: 60,
        numeric: true,
        update: true,
        input: true,
        disabled: true
      },
      {
        headerName: 'BH (in)',
        propertyName: 'bh',
        width: 1,
        minWidth: 60,
        numeric: true,
        update: true,
        input: true,
        disabled: true
      },
      {
        headerName: 'ST (in)',
        propertyName: 'st',
        width: 1,
        minWidth: 60,
        numeric: true,
        update: true,
        input: true,
        disabled: true
      },
      {
        headerName: 'SB (in)',
        propertyName: 'sb',
        width: 1,
        minWidth: 60,
        numeric: true,
        update: true,
        input: true,
        disabled: true
      },
      {
        headerName: 'SH (in)',
        propertyName: 'sh',
        width: 1,
        minWidth: 60,
        numeric: true,
        update: true,
        input: true,
        disabled: true
      },
      {
        headerName: 'Volume',
        propertyName: 'volume',
        width: 1,
        minWidth: 60,
        numeric: true,
        update: false,
        input: false,
        disabled: false
      },
      {
        headerName: 'Tester Initials',
        propertyName: 'dimensionTester',
        width: 2,
        minWidth: 100,
        numeric: false,
        update: true,
        input: true,
        disabled: true
      },
      {
        headerName: 'Mass',
        propertyName: 'mass',
        width: 1,
        minWidth: 60,
        numeric: true,
        update: true,
        input: true,
        disabled: true
      },
      {
        headerName: 'Tester Initials',
        propertyName: 'massTester',
        width: 2,
        minWidth: 100,
        numeric: false,
        update: true,
        input: true,
        disabled: true
      },
      {
        headerName: 'Date',
        propertyName: 'densityDate',
        width: 2,
        minWidth: 80,
        numeric: false,
        update: true,
        input: true,
        disabled: true
      }
    ]
    let currentDate
    let database
    const headers = []
    const sheetNames = ['Blocks DB', 'Blocks1364DB']
    let blocksCollection
    function doOnload () {
      function getDatabaseOnLoad () {
        currentDate = new Date()
        document.getElementById('loadingDatabase').style.display = 'block'
        google.script.run.withSuccessHandler(onSuccess).withFailureHandler(onFailure).getDatabase()
        function onSuccess (gotDatabase) {
          console.log('loaded database in ' + (Date.now() - currentDate.getTime()) / 1000 + ' s')
          database = [gotDatabase.sheet1, gotDatabase.sheet2]
          const blocks = []
          headers[0] = database[0][0]
          for (let i = 1; i < database[0].length; i++) {
            if (database[0][i][columns.block] !== '' && !isNaN(database[0][i][columns.block])) {
              blocks.push(new Block(database[0][i], 0, i + 1, blocks.length))
            }
          }
          headers[1] = database[1][0]
          for (let i = 1; i < database[1].length; i++) {
            if (database[1][i][columns.block] !== '' && !isNaN(database[1][i][columns.block])) {
              blocks.push(new Block(database[1][i], 1, i + 1, blocks.length))
            }
          }
          blocksCollection = new BlocksCollection(blocks)
          document.getElementById('loadingDatabase').style.display = 'none'
          document.getElementById('sectionSelection').style.display = 'block'
          setupGridTables()
          addRowByConfig('tungstenGridTable', tungstenConfig, tungstenRows, tungstenKeyup, 8)
          addRowByConfig('epoxyGridTable', epoxyConfig, epoxyRows, epoxyKeyup, 8)
          addRowByConfig('densityGridTable', densityConfig, densityRows, densityKeyup, 8)
        }
        function onFailure (err) {
          console.warn('failed to load database...retrying in 10 seconds')
          window.setTimeout(getDatabaseOnLoad, 10000)
          throw err
        }
        $('input.batchDateUS').val(dateToUS(currentDate))
        $('input.batchDate').val(dateToYYYYMMDD(currentDate))
      }
      try {
        getDatabaseOnLoad()
      } catch (err) {
        console.error('unexpected error while getting database...retrying in 10 seconds')
        window.setTimeout(getDatabaseOnLoad, 10000)
        throw (err)
      }
    }
    function setupGridTables () {
      addHeaders('tungstenGridTable', tungstenConfig)
      addHeaders('epoxyGridTable', epoxyConfig)
      addHeaders('densityGridTable', densityConfig)
      function addHeaders (tableID, tableConfig) {
        const table = $('#' + tableID)
        let template = ''
        for (const config of tableConfig) {
          table.append($('<div>' + config.headerName + '</div>').addClass('gridTableHeader'))
          template += config.width + 'fr '
        }
        table.css('grid-template-columns', template).css('margin-top', '1em')
      }
    }
    const tungstenRows = []
    const epoxyRows = []
    const densityRows = []
    function addRowByConfig (tableID, tableConfig, rows, keyup, count) {
      const numRows = Math.floor($('#' + tableID + ' > div.gridData').length / 8)
      for (let i = 0; i < count; i++) {
        const row = []
        const rowNum = numRows + i
        for (const config of tableConfig) {
          const element = $('<div></div>').addClass('gridData')
          let child
          if (config.input) {
            child = $('<input/>').attr('type', 'text').attr('data-row', rowNum).css('min-width', config.minWidth + 'px')
              .prop('placeholder', '').keyup(function () { keyup(rowNum) })
          } else {
            child = $('<p></p>').attr('data-row', rowNum).addClass('centerP').css('min-width', config.minWidth + 'px')
          }
          if (config.disabled) {
            child.prop('disabled', true).addClass('fillEmpty')
          }
          element.append(child)
          row.push(element)
        }
        $('#' + tableID).append(row)
        const rowData = $('#' + tableID).find('[data-row="' + (numRows + i) + '"]').toArray()
        rows.push(rowData)
      }
    }
    function tungstenKeyup (row) {
      const rowData = tungstenRows[parseInt(row)]
      const block = blocksCollection.getBlockByStringDBN(rowData[0].value)
      const toUpdate = rowData.slice(1, 8)
      if (rowData[0].value !== '' && block != null) {
        toUpdate.forEach(function (element) {
          element.disabled = false
          element.style.backgroundColor = 'transparent'
        })
        updateTextInput(rowData[1], block.powder)
        updateTextInput(rowData[2], block.bucket)
        updateTextInput(rowData[3], block.moldSeries)
        updateTextInput(rowData[4], block.emptyMoldMass)
        updateTextInput(rowData[5], block.filledMoldMass)
        updateTextInput(rowData[6], block.tungstenFillingDate)
        updateTextInput(rowData[7], block.tungstenFiller)
      } else {
        toUpdate.forEach(function (element) {
          element.value = ''
          element.placeholder = ''
          element.disabled = true
          element.style.border = '1px solid grey'
          element.style.backgroundColor = '#eee'
        })
      }
    }
    function epoxyKeyup (row) {
      const rowData = epoxyRows[parseInt(row)]
      const block = blocksCollection.getBlockByStringDBN(rowData[0].value)
      const toUpdate = rowData.slice(1, 8)
      if (rowData[0].value !== '' && block != null) {
        toUpdate.forEach(function (element) {
          element.disabled = false
          element.style.backgroundColor = 'transparent'
        })
        updateTextInput(rowData[1], block.epoxyBatch)
        updateTextInput(rowData[2], block.resinMass)
        updateTextInput(rowData[3], block.hardenerMass)
        updateTextInput(rowData[4], block.pottingNotes)
        updateTextInput(rowData[5], block.epoxyFillingTime)
        updateTextInput(rowData[6], block.epoxyFillingDate)
        updateTextInput(rowData[7], block.epoxyPreparer)
      } else {
        toUpdate.forEach(function (element) {
          element.value = ''
          element.placeholder = ''
          element.disabled = true
          element.style.border = '1px solid grey'
          element.style.backgroundColor = '#eee'
        })
      }
    }
    function densityKeyup (row) {
      // console.log('density keyup at row ' + row)
      const rowData = densityRows[row]
      // console.log(rowData)
      const block = blocksCollection.getBlockByStringDBN(rowData[0].value)
      const toUpdate = rowData.slice(1, 8).concat(rowData.slice(9, 13))
      if (rowData[0].value !== '' && block != null) {
        toUpdate.forEach(function (element) {
          element.disabled = false
          element.style.backgroundColor = 'transparent'
        })
        const l = block.l
        const bt = block.bt
        const bb = block.bb
        const bh = block.bh
        const st = block.st
        const sb = block.sb
        const sh = block.sh
        const blockDimensions = [l, bt, bb, bh, st, sb, sh]
        const inputDimensions = []
        rowData.slice(1, 8).forEach(function (element) {
          if (element.value === '' || isNaN(element.value)) {
            inputDimensions.push(null)
          } else {
            inputDimensions.push(Number(element.value))
          }
        })
        const useDimensions = []
        // console.log('block: ' + JSON.stringify(blockDimensions))
        // console.log('input: ' + JSON.stringify(inputDimensions))
        for (let i = 0; i < inputDimensions.length; i++) {
          if (inputDimensions[i] != null) {
            useDimensions.push(inputDimensions[i])
          } else {
            useDimensions.push(blockDimensions[i])
          }
        }
        if (useDimensions.every((element) => element != null)) {
          // console.log(JSON.stringify(useDimensions))
          const vol = getVolume(useDimensions)
          rowData[8].innerHTML = vol.toFixed(1)
          // console.log('DBN ' + block.dbn + ' has volume ' + vol)
        } else {
          rowData[8].innerHTML = ''
        }
        // console.log(rowData)
        updateTextInput(rowData[1], block.l == null ? null : block.l.toFixed(4))
        updateTextInput(rowData[2], block.bt == null ? null : block.bt.toFixed(4))
        updateTextInput(rowData[3], block.bb == null ? null : block.bb.toFixed(4))
        updateTextInput(rowData[4], block.bh == null ? null : block.bh.toFixed(4))
        updateTextInput(rowData[5], block.st == null ? null : block.st.toFixed(4))
        updateTextInput(rowData[6], block.sb == null ? null : block.sb.toFixed(4))
        updateTextInput(rowData[7], block.sh == null ? null : block.sh.toFixed(4))

        updateTextInput(rowData[9], block.dimensionTester)
        updateTextInput(rowData[10], block.mass)
        updateTextInput(rowData[11], block.massTester)
        updateTextInput(rowData[12], block.densityDate)
      } else {
        toUpdate.forEach(function (element) {
          element.value = ''
          element.placeholder = ''
          element.disabled = true
          element.style.border = '1px solid grey'
          element.style.backgroundColor = '#eee'
        })
        rowData[8].innerHTML = ''
      }
    }
    function updateTextInput (element, databaseValue) {
      if (databaseValue != null) {
        element.placeholder = databaseValue
        if (element.value === '') {
          element.style.border = '2px solid orange'
        } else {
          element.style.border = '2px solid red'
        }
      } else {
        element.placeholder = ''
        if (element.value === '') {
          element.style.border = '1px solid grey'
        } else {
          element.style.border = '2px solid green'
        }
      }
    }
    function batchInput (form, className) {
      const grid = $(form).parent('section').children('div.grid').eq(0)
      const inputVal = $(form).children('input').eq(0).val()
      grid.find('div.gridData > input.' + className).filter(':enabled').val(inputVal).keyup()
    }
    function loadTungsten () {
      document.getElementById('sectionSelection').style.display = 'none'
      document.getElementById('tungstenSection').style.display = 'block'
    }
    function loadEpoxy () {
      document.getElementById('sectionSelection').style.display = 'none'
      document.getElementById('epoxySection').style.display = 'block'
    }
    function loadDensity () {
      document.getElementById('sectionSelection').style.display = 'none'
      document.getElementById('densitySection').style.display = 'block'
    }
    function sectionReturn () {
      $('.dataEntrySection').css('display', 'none')
      document.getElementById('sectionSelection').style.display = 'block'
    }
    function onLogBlock () {
      const blockName = document.getElementById('logBlockInput').value
      const start = Date.now()
      const block = blocksCollection.getBlockByStringDBN(blockName)
      if (block != null) {
        // google.script.run.withSuccessHandler(onSuccess).withFailureHandler(onFailure).getRowData([{sheet: block.sheet, row: block.row}])
        console.log(block)
      } else {
        console.log("unable to locate that DBN (here's where I would offer you an option to refresh the database for another opportunity to find that block)")
      }
      function onSuccess (data) {
        const blockData = data[0]
        if (blockData != null) {
          console.log('found that block in ' + (Date.now() - start) / 1000 + ' s')
          console.log(blockData)
        } else {
          console.log('unable to locate that block')
        }
      }
      function onFailure (err) {
        throw err
      }
    }
    function submitTungstenData () {
      const blocks = []
      const values = []
      const columnNames = ['powder', 'bucket', 'moldSeries', 'emptyMoldMass', 'filledMoldMass', 'tungstenFillingDate', 'tungstenFiller']
      for (const tungstenRow of tungstenRows) {
        const stringDBN = tungstenRow[0].value
        if (stringDBN !== '') {
          const block = blocksCollection.getBlockByStringDBN(stringDBN)
          if (block != null) {
            blocks.push(block)
            const blockValues = []
            for (let i = 0; i < columnNames.length; i++) {
              let _set = tungstenRow[i + 1].value
              if (_set !== '') {
                let _expected = block[columnNames[i]]
                if (_expected == null) { _expected = '' }
                // cast set value to num if needed
                let config
                for (const obj of tungstenConfig) {
                  if (obj.propertyName === columnNames[i]) {
                    config = obj
                    break
                  }
                }
                if (config.numeric && _set !== '' && !isNaN(_set)) {
                  _set = Number(_set)
                }
                blockValues.push({ set: _set, expected: _expected, ignoreError: false })
              } else {
                blockValues.push(null)
              }
            }
            values.push(blockValues)
          } else {
            console.error('unable to find DBN ' + stringDBN + ' (I could offer to refresh database here)')
          }
        }
      }
      submitData(blocks, columnNames, values)
    }

    function submitEpoxyData () {
      const blocks = []
      const values = []
      const columnNames = ['epoxyBatch', 'resinMass', 'hardenerMass', 'pottingNotes', 'epoxyFillingTime', 'epoxyFillingDate', 'epoxyPreparer']
      for (const epoxyRow of epoxyRows) {
        const stringDBN = epoxyRow[0].value
        if (stringDBN !== '') {
          const block = blocksCollection.getBlockByStringDBN(stringDBN)
          if (block != null) {
            blocks.push(block)
            const blockValues = []
            for (let i = 0; i < columnNames.length; i++) {
              let _set = epoxyRow[i + 1].value
              if (_set !== '') {
                let _expected = block[columnNames[i]]
                if (_expected == null) { _expected = '' }
                // cast set value to num if needed
                let config
                for (const obj of epoxyConfig) {
                  if (obj.propertyName === columnNames[i]) {
                    config = obj
                    break
                  }
                }
                if (config.numeric && _set !== '' && !isNaN(_set)) {
                  _set = Number(_set)
                }
                blockValues.push({ set: _set, expected: _expected, ignoreError: false })
              } else {
                blockValues.push(null)
              }
            }
            values.push(blockValues)
          } else {
            console.error('unable to find DBN ' + stringDBN + ' (I could offer to refresh database here)')
          }
        }
      }
      submitData(blocks, columnNames, values)
    }
    function submitDensityData () {
      const blocks = []
      const values = []
      const columnNames = ['l', 'bt', 'bb', 'bh', 'st', 'sb', 'sh', 'dimensionTester', 'mass', 'massTester', 'densityDate']
      for (const densityRowAll of densityRows) {
        const stringDBN = densityRowAll[0].value
        // this is not an ideal solution:
        const densityRow = densityRowAll.slice(0, 8).concat(densityRowAll.slice(9)) // densityRow.splice(8, 1)
        if (stringDBN !== '') {
          const block = blocksCollection.getBlockByStringDBN(stringDBN)
          if (block != null) {
            blocks.push(block)
            const blockValues = []
            for (let i = 0; i < columnNames.length; i++) {
              let _set = densityRow[i + 1].value
              if (_set !== '') {
                let _expected = block[columnNames[i]]
                if (_expected == null) { _expected = '' }
                // cast set value to num if needed
                let config
                for (const obj of densityConfig) {
                  if (obj.propertyName === columnNames[i]) {
                    config = obj
                    break
                  }
                }
                if (config.numeric && _set !== '' && !isNaN(_set)) {
                  _set = Number(_set)
                }
                blockValues.push({ set: _set, expected: _expected, ignoreError: false })
              } else {
                blockValues.push(null)
              }
            }
            values.push(blockValues)
          } else {
            console.error('unable to find DBN ' + stringDBN + ' (I could offer to refresh database here)')
          }
        }
      }
      submitData(blocks, columnNames, values)
    }
    
    /**
     * submits data to the database
     * @param {Block[]} blocks Array of blocks
     * @param {String[]} columnNames Names of columns (which correspond to the columns in values)
     * @param {String[][]} values Values to submit to the database (row corresponds to blocks, column corresponds to columnNames)
     */
    function submitData (blocks, columnNames, values) {
      // first, organize data to send to the google script
      const data = []
      const cols = []
      for (const name of columnNames) {
        cols.push(columns[name])
      }
      for (let i = 0; i < blocks.length; i++) {
        const block = blocks[i]
        const blockData = {}
        blockData.sheet = block.sheet
        blockData.row = block.row
        blockData.cols = []
        blockData.values = []
        for (let j = 0; j < values[i].length; j++) {
          if (values[i][j] != null) {
            blockData.cols.push(cols[j])
            blockData.values.push(values[i][j])
          }
        }
        data.push(blockData)
      }
      // next, check if we know this data will overwrite existing data if submitted
      const overwriteWarnings = validateOverwrites(blocks, columnNames, values)
      if (overwriteWarnings.length !== 0) {
        // if there are overwrites, ask to confirm before proceeding
        showOverwriteWarnings(overwriteWarnings, blocks, columnNames, values, data)
      } else {
        // if not, proceed to perform basic data validation before sending to google script
        const basicDataValidationWarnings = validateData(blocks, columnNames, values)
        if (basicDataValidationWarnings.length !== 0) {
          showWarnings(basicDataValidationWarnings, data)
        } else {
          // submit to the google script
          google.script.run.withSuccessHandler(onSubmitDataSuccess).withFailureHandler(onFailure).setBlockData(data)
        }
      }
    
      function validateOverwrites (blocks, columnNames, values) {
        const warnings = []
        // console.log(values)
        for (let i = 0; i < values.length; i++) {
          const block = blocks[i]
          for (let j = 0; j < columnNames.length; j++) {
            const value = values[i][j]
            // console.log(value)
            if (value !== null && value.set != value.expected) {
              warnings.push({
                set: value.set,
                prev: value.expected,
                col: columnNames[j],
                dbn: block.dbn,
                value: value.set
              })
            }
          }
        }
        return warnings
      }
      function showOverwriteWarnings (overwriteWarnings, blocks, columnNames, values, data) {
        // console.log(data)
        let warningMsg = '(WARNING) This submission would overwrite some data in the database:\n'
        for (const warn of overwriteWarnings) {
          warningMsg += 'DBN ' + warn.dbn + ', column "' + warn.col +
          '": (warning) changing value "' + warn.prev + '" → "' + warn.set + '"\n'
        }
        warningMsg += 'Are you sure you want to submit this data to the database?'
        const bool = confirm(warningMsg)
        if (bool) {
          // overwrite was confirmed, perform basic data validation before sending to google script
          const warnings = validateData(blocks, columnNames, values)
          if (warnings.length !== 0) {
            showWarnings(warnings, data)
          } else {
            // submit to the google script
            google.script.run.withSuccessHandler(onSubmitDataSuccess).withFailureHandler(onFailure).setBlockData(data)
          }
        }
      }
    
      function validateData (blocks, columnNames, values) {
        const warnings = []
        // console.log(values)
        for (let i = 0; i < values.length; i++) {
          const block = blocks[i]
          for (let j = 0; j < columnNames.length; j++) {
            const value = values[i][j]
            // console.log(value)
            if (value != null && Object.prototype.hasOwnProperty.call(validate, columnNames[j])) {
              const validation = validate[columnNames[j]](value.set)
              if (!validation.valid) {
                warnings.push({
                  msg: validation.msg,
                  col: columnNames[j],
                  dbn: block.dbn,
                  value: value.set
                })
              }
            }
          }
        }
        return warnings
      }
      function showWarnings (warnings, data) {
        // console.log(data)
        let warningMsg = '(WARNING) Some of the data is not as expected:\n'
        for (const warn of warnings) {
          warningMsg += 'DBN ' + warn.dbn + ', column "' + warn.col +
          '": (warning) for value "' + warn.value + '", ' + warn.msg + '\n'
        }
        warningMsg += 'Are you sure you want to submit this data to the database?'
        const bool = confirm(warningMsg)
        if (bool) {
          google.script.run.withSuccessHandler(onSubmitDataSuccess).withFailureHandler(onFailure).setBlockData(data)
        }
      }
    
      function showErrorAlert (msg, data) {
        if (msg.dataValidationErrors.length !== 0 || msg.unexpectedValueErrors.length !== 0) {
          let errorMsg = ''
          const fatalErrors = []
          for (const error of msg.dataValidationErrors) {
            if (error.fatal) {
              fatalErrors.push(error)
            }
          }
          if (fatalErrors.length !== 0) {
            // show an alert: UNABLE to submit this data because these errors (the fatal errors)
            errorMsg += '(ERROR) Unable to submit data to the database due to these data validation errors:\n'
            for (const error of fatalErrors) {
              const dbn = blocksCollection.getBlockByLocation(error.loc.sheet, error.loc.row).dbn
              if (error.type === 'VALUE_IN_LIST') {
                errorMsg += 'In sheet ' + sheetNames[error.loc.sheet] + ', DBN ' + dbn +
                ' (row ' + error.loc.row + '), column "' + (headers[error.loc.sheet][error.loc.col]) +
                '": tried to write value "' + error.value + '" but cell requires a value in ' + JSON.stringify(error.args[0]) + '\n'
              } else if (error.type === 'DATE_IS_VALID_DATE') {
                errorMsg += 'In sheet ' + sheetNames[error.loc.sheet] + ', DBN ' + dbn +
                ' (row ' + error.loc.row + '), column "' + (headers[error.loc.sheet][error.loc.col]) +
                '": tried to write value "' + error.value + '" but cell requires a valid date\n'
              } else {
                errorMsg += 'In sheet ' + sheetNames[error.loc.sheet] + ', DBN ' + dbn +
                ' (row ' + error.loc.row + '), column "' + (headers[error.loc.sheet][error.loc.col]) +
                '": unknown data validation type (' + error.type + ') at value "' + error.value + '": ' + JSON.stringify(error.args[0]) + '\n'
                errorMsg += JSON.stringify(error) + '\n'
              }
            }
            alert(errorMsg)
          } else {
            // no fatal errors, show warnings and ask to confirm
            if (msg.dataValidationErrors.length !== 0) {
              errorMsg += '(WARNING) Encountered the following unchecked data validation warnings while trying to write to the database:\n'
              for (const error of msg.dataValidationErrors) {
                const dbn = blocksCollection.getBlockByLocation(error.loc.sheet, error.loc.row).dbn
                if (error.type === 'VALUE_IN_LIST') {
                  errorMsg += 'In sheet ' + sheetNames[error.loc.sheet] + ', DBN ' + dbn +
                  ' (row ' + error.loc.row + '), column "' + (headers[error.loc.sheet][error.loc.col]) +
                  '": tried to write value "' + error.value + '" but cell suggests a value in ' + JSON.stringify(error.args[0]) + '\n'
                } else if (error.type === 'DATE_IS_VALID_DATE') {
                  errorMsg += 'In sheet ' + sheetNames[error.loc.sheet] + ', DBN ' + dbn +
                  ' (row ' + error.loc.row + '), column "' + (headers[error.loc.sheet][error.loc.col]) +
                  '": tried to write value "' + error.value + '" but cell suggests a valid date\n'
                } else {
                  errorMsg += 'In sheet ' + sheetNames[error.loc.sheet] + ', DBN ' + dbn +
                  ' (row ' + error.loc.row + '), column "' + (headers[error.loc.sheet][error.loc.col]) +
                  '": encountered an unknown data validation type (' + error.type + ') for value "' + error.value + '": ' + JSON.stringify(error.args[0]) + '\n'
                  errorMsg += JSON.stringify(error) + '\n'
                }
              }
            }
            if (msg.unexpectedValueErrors.length !== 0) {
              errorMsg += '(WARNING) Found the following unexpected values in the database (did these cells change since this page was loaded?):\n'
              for (const error of msg.unexpectedValueErrors) {
                const dbn = blocksCollection.getBlockByLocation(error.loc.sheet, error.loc.row).dbn
                errorMsg += 'In sheet ' + sheetNames[error.loc.sheet] + ', DBN ' + dbn +
                ' (row ' + error.loc.row + '), column "' + (headers[error.loc.sheet][error.loc.col]) +
                '": expected value "' + error.expected + '" but found "' + error.found + '"\n'
              }
            }
            errorMsg += 'Press OK to ignore these errors and submit this data to the database'
            const bool = confirm(errorMsg)
            if (bool) {
              for (const error of msg.dataValidationErrors.concat(msg.unexpectedValueErrors)) {
                const i = error.id[0]
                const j = error.id[1]
                data[i].values[j].ignoreError = true
              }
              google.script.run.withSuccessHandler(onSubmitDataSuccess).withFailureHandler(onFailure).setBlockData(data)
            }
          }
        } else {
          const successMsg = 'Successfully wrote data to the database'
          alert(successMsg)
        }
      }
      function onSubmitDataSuccess (msg) {
        // console.log(msg)
        showErrorAlert(msg, data)
      }
      function onFailure (err) {
        throw err
      }
    }
    
    function updateDatabase() {
      const start = Date.now()
      google.script.run.withSuccessHandler(onSuccess).withFailureHandler(onFailure).getDatabase()
      function onSuccess (sheets) {
        console.log('loaded database in ' + (Date.now() - start) / 1000 + ' s')
        database = [sheets.sheet1, sheets.sheet2]
        headers[0] = database[0][0]
        for (let i = 1; i < database[0].length; i++) {
          if (database[0][i][columns.block] !== '' && !isNaN(database[0][i][columns.block])) {
            blocksCollection.updateBlock(database[0][i], 0, i + 1)
          }
        }
        headers[1] = database[1][0]
        for (let i = 1; i < database[1].length; i++) {
          if (database[1][i][columns.block] !== '' && !isNaN(database[1][i][columns.block])) {
            blocksCollection.updateBlock(database[1][i], 1, i + 1)
          }
        }
      }
      function onFailure (err) {
        throw err
      }
      // should also somehow update the UI (idk if there's a nice way to do this)
    }
  </script>
</html>
