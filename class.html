<!DOCTYPE html>
<html>
  <script>
    class Block {
      constructor (array, sheet, row, index) {
        this.sheet = sheet
        this.row = row
        this.index = index
        this.dbn = array[0]
        this.block = parseInt(array[2])
        this.status = array[3]
        this.powder = (!dataPresent(array[14])) ? null : array[14]
        this.bucket = (!dataPresent(array[15])) ? null : array[15]
        this.moldSeries = (!dataPresent(array[16])) ? null : array[16]
        this.emptyMoldMass = (!dataPresent(array[17])) ? null : parseInt(array[17])
        this.filledMoldMass = (!dataPresent(array[18])) ? null : parseInt(array[18])
        this.tungstenMass = (!dataPresent(array[19]) || parseInt(array[19]) === 0) ? null : parseInt(array[19])
        this.tungstenFillingDate = (!dataPresent(array[21])) ? null : array[21]
        this.tungstenFiller = (!dataPresent(array[22])) ? null : array[22]
        this.epoxyBatch = (!dataPresent(array[23])) ? null : parseInt(array[23])
        this.resinMass = (!dataPresent(array[24])) ? null : parseInt(array[24])
        this.hardenerMass = (!dataPresent(array[25])) ? null : parseInt(array[25])
        this.pottingNotes = (!dataPresent(array[26])) ? null : array[26]
        this.epoxyFillingTime = (!dataPresent(array[27])) ? null : parseFloat(array[27])
        this.epoxyFillingDate = (!dataPresent(array[28])) ? null : array[28]
        this.epoxyPreparer = (!dataPresent(array[29])) ? null : array[29]
        this.l = (!dataPresent(array[33])) ? null : parseFloat(array[33])
        this.bt = (!dataPresent(array[34])) ? null : parseFloat(array[34])
        this.bb = (!dataPresent(array[35])) ? null : parseFloat(array[35])
        this.bh = (!dataPresent(array[36])) ? null : parseFloat(array[36])
        this.st = (!dataPresent(array[37])) ? null : parseFloat(array[37])
        this.sb = (!dataPresent(array[38])) ? null : parseFloat(array[38])
        this.sh = (!dataPresent(array[39])) ? null : parseFloat(array[39])
        this.volume = (!dataPresent(array[40]) || parseInt(array[40]) === 0) ? null : parseFloat(array[40])
        this.dimensionTester = (!dataPresent(array[41])) ? null : array[41]
        this.mass = (!dataPresent(array[42])) ? null : parseInt(array[42])
        this.massTester = (!dataPresent(array[43])) ? null : array[43]
        this.density = (!dataPresent(array[44])) ? null : parseFloat(array[44])
        this.densityDate = (!dataPresent(array[45])) ? null : parseInt(array[45])
      }

      deviations () {
        const tols = [this.l, this.bt, this.bb, this.bh, this.st, this.sb, this.sh]
        if (tols.every((value) => value != null)) {
          const devs = []
          tols.forEach((value, index) => devs[index] = value - dimensionsMap.get(this.block)[index])
          return devs
        } else {
          return null
        }
      }

      testGrades () {
        if (this.sheet === 0) {
          const devs = this.deviations()
          const devGrades = new Array(7)
          if (devs == null) {
            devGrades.fill(notStartedGrade)
          } else {
            for (let i = 0; i < devs.length; i++) {
              if (i === 0) {
                devGrades[0] = (devs[0] == null) ? notStartedGrade : grade_dL(devs[0])
              } else {
                devGrades[i] = (devs[i] == null) ? notStartedGrade : grade_otherDev(devs[i])
              }
            }
          }
          const densityValuesToGrade = [
            ((this.density == null) ? notStartedGrade : grade_density(this.density)),
            ...devGrades
          ]
          const densityGrade = Math.max(...densityValuesToGrade)
          return {
            density: densityGrade,
            tolerances: devGrades
          }
        } else {
          return null
        }
      }
    }
    class BlocksCollection {
      constructor (array) {
        this.array = array
        // console.log('new blocks collection with array length ' + array.length)
      }

      getBlockByIndex (index) {
        return this.array[index]
      }

      getBlockByStringDBN (stringDBN) {
        let index
        // shame we can't use a binary search here (string DBNs are not sorted), but it really doesn't take that long
        this.array.forEach(function (block, _index, array) {
          if (stringDBN === block.dbn) {
            index = _index
          }
        })
        if (index != null) { return this.array[index] }
      }
    
      getBlocksNeedingRetouch (retouchStatus) {
        const blocks = []
        const devNames = ['L', 'BT', 'BB', 'BH', 'ST', 'SB', 'SH']
        const allowedStatuses = ['5', '5a', '5b', '5c']
        this.array.forEach(function (block) {
          if (block.deviations() != null && block.retouch === retouchStatus && allowedStatuses.includes(block.status)) {
            const retouchDevs = []
            block.deviations().forEach(function (dev, index) {
              if (index === 0) {
                if (grade_dL(dev) === fGrade && dev > 0) {
                  retouchDevs.push([devNames[index], dev])
                }
              } else if (grade_otherDev(dev) === fGrade && dev > 0) {
                retouchDevs.push([devNames[index], '+' + dev.toFixed(4)])
              }
            })
            if (retouchDevs.length > 0) {
              blocks.push([block, retouchDevs])
            }
          }
        })
        return blocks
      }
    }
  </script>
</html>